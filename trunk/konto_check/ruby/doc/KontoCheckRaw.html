<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Module: KontoCheckRaw
  
    &mdash; Documentation by YARD 0.8.2.1
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (K)</a> &raquo;
    
    
    <span class="title">KontoCheckRaw</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Module: KontoCheckRaw
  
  
  
</h1>

<dl class="box">
  
  
    
  
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">ext/konto_check_raw/konto_check_raw_ruby.c</dd>
  
</dl>
<div class="clear"></div>


  <h2>Constant Summary</h2>
  
    <dl class="constants">
      
        <dt id="BIC_ONLY_GERMAN-constant" class="">BIC_ONLY_GERMAN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-145) Es werden nur deutsche BICs unterstützt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>BIC_ONLY_GERMAN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_BIC_LENGTH-constant" class="">INVALID_BIC_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-144) Die Länge des BIC muß genau 8 oder 11 Zeichen sein</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_BIC_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_RULE_IGNORED_BLZ-constant" class="">IBAN_CHKSUM_OK_RULE_IGNORED_BLZ =
          <div class="docstring">
  <div class="discussion">
    
<p>(-143) Die IBAN-Prüfsumme stimmt, die BLZ sollte aber durch eine zentrale
BLZ ersetzt werden. Die Richtigkeit der IBAN kann nur mit einer Anfrage bei
der Bank ermittelt werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_RULE_IGNORED_BLZ</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_KC_NOT_INITIALIZED-constant" class="">IBAN_CHKSUM_OK_KC_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-142) Die IBAN-Prüfsumme stimmt, konto_check wurde jedoch noch nicht
initialisiert (Kontoprüfung nicht möglich)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_KC_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_BLZ_INVALID-constant" class="">IBAN_CHKSUM_OK_BLZ_INVALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(-141) Die IBAN-Prüfsumme stimmt, die BLZ ist allerdings ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_BLZ_INVALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_NACHFOLGE_BLZ_DEFINED-constant" class="">IBAN_CHKSUM_OK_NACHFOLGE_BLZ_DEFINED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-140) Die IBAN-Prüfsumme stimmt, für die Bank gibt es allerdings eine
(andere) Nachfolge-BLZ</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_NACHFOLGE_BLZ_DEFINED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NOT_ALL_IBAN_BLOCKS_LOADED-constant" class="">LUT2_NOT_ALL_IBAN_BLOCKS_LOADED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-139) es konnten nicht alle Datenblocks die für die IBAN-Berechnung
notwendig sind geladen werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NOT_ALL_IBAN_BLOCKS_LOADED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NOT_YET_VALID_PARTIAL_OK-constant" class="">LUT2_NOT_YET_VALID_PARTIAL_OK =
          <div class="docstring">
  <div class="discussion">
    
<p>(-138) Der Datensatz ist noch nicht gültig, außerdem konnten nicht alle
Blocks geladen werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NOT_YET_VALID_PARTIAL_OK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_LONGER_VALID_PARTIAL_OK-constant" class="">LUT2_NO_LONGER_VALID_PARTIAL_OK =
          <div class="docstring">
  <div class="discussion">
    
<p>(-137) Der Datensatz ist nicht mehr gültig, außerdem konnten nicht alle
Blocks geladen werdeng</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_LONGER_VALID_PARTIAL_OK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_BLOCKS_MISSING-constant" class="">LUT2_BLOCKS_MISSING =
          <div class="docstring">
  <div class="discussion">
    
<p>(-136) ok, bei der Initialisierung konnten allerdings ein oder mehrere
Blocks nicht geladen werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_BLOCKS_MISSING</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FALSE_UNTERKONTO_ATTACHED-constant" class="">FALSE_UNTERKONTO_ATTACHED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-135) falsch, es wurde ein Unterkonto hinzugefügt (IBAN-Regel)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FALSE_UNTERKONTO_ATTACHED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="BLZ_BLACKLISTED-constant" class="">BLZ_BLACKLISTED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-134) Die BLZ findet sich in der Ausschlussliste für IBAN-Berechnungen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>BLZ_BLACKLISTED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="BLZ_MARKED_AS_DELETED-constant" class="">BLZ_MARKED_AS_DELETED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-133) Die BLZ ist in der Bundesbank-Datei als gelöscht markiert und somit
ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>BLZ_MARKED_AS_DELETED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_SOMETHING_WRONG-constant" class="">IBAN_CHKSUM_OK_SOMETHING_WRONG =
          <div class="docstring">
  <div class="discussion">
    
<p>(-132) Die IBAN-Prüfsumme stimmt, es gibt allerdings einen Fehler in der
eigenen IBAN-Bestimmung (wahrscheinlich falsch)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_SOMETHING_WRONG</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_NO_IBAN_CALCULATION-constant" class="">IBAN_CHKSUM_OK_NO_IBAN_CALCULATION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-131) Die IBAN-Prüfsumme stimmt. Die Bank gibt IBANs nach nicht
veröffentlichten Regeln heraus, die Richtigkeit der IBAN kann nur mit einer
Anfrage bei der Bank ermittelt werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_NO_IBAN_CALCULATION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_RULE_IGNORED-constant" class="">IBAN_CHKSUM_OK_RULE_IGNORED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-130) Die IBAN-Prüfsumme stimmt, es wurde allerdings eine IBAN-Regel nicht
beachtet (wahrscheinlich falsch)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_RULE_IGNORED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_CHKSUM_OK_UNTERKTO_MISSING-constant" class="">IBAN_CHKSUM_OK_UNTERKTO_MISSING =
          <div class="docstring">
  <div class="discussion">
    
<p>(-129) Die IBAN-Prüfsumme stimmt, es fehlt aber ein Unterkonto
(wahrscheinlich falsch)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_CHKSUM_OK_UNTERKTO_MISSING</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_INVALID_RULE-constant" class="">IBAN_INVALID_RULE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-128) Die BLZ passt nicht zur angegebenen IBAN-Regel</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_INVALID_RULE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_AMBIGUOUS_KTO-constant" class="">IBAN_AMBIGUOUS_KTO =
          <div class="docstring">
  <div class="discussion">
    
<p>(-127) Die Kontonummer ist nicht eindeutig (es gibt mehrere Möglichkeiten)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_AMBIGUOUS_KTO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_RULE_NOT_IMPLEMENTED-constant" class="">IBAN_RULE_NOT_IMPLEMENTED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-126) Die IBAN-Regel ist noch nicht implementiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_RULE_NOT_IMPLEMENTED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_RULE_UNKNOWN-constant" class="">IBAN_RULE_UNKNOWN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-125) Die IBAN-Regel ist nicht bekannt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_RULE_UNKNOWN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NO_IBAN_CALCULATION-constant" class="">NO_IBAN_CALCULATION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-124) Für die Bankverbindung ist keine IBAN-Berechnung erlaubt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NO_IBAN_CALCULATION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OLD_BLZ_OK_NEW_NOT-constant" class="">OLD_BLZ_OK_NEW_NOT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-123) Die Bankverbindung ist mit der alten BLZ stimmig, mit der
Nachfolge-BLZ nicht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OLD_BLZ_OK_NEW_NOT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_IBAN_REGEL_NOT_INITIALIZED-constant" class="">LUT2_IBAN_REGEL_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-122) Das Feld IBAN-Regel wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_IBAN_REGEL_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_IBAN_LENGTH-constant" class="">INVALID_IBAN_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-121) Die Länge der IBAN für das angegebene Länderkürzel ist falsch</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_IBAN_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_ACCOUNT_GIVEN-constant" class="">LUT2_NO_ACCOUNT_GIVEN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-120) Keine Bankverbindung/IBAN angegeben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_ACCOUNT_GIVEN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_VOLLTEXT_INVALID_CHAR-constant" class="">LUT2_VOLLTEXT_INVALID_CHAR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-119) Ungültiges Zeichen ( ()+-/&amp;.,' ) für die Volltextsuche gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_VOLLTEXT_INVALID_CHAR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_VOLLTEXT_SINGLE_WORD_ONLY-constant" class="">LUT2_VOLLTEXT_SINGLE_WORD_ONLY =
          <div class="docstring">
  <div class="discussion">
    
<p>(-118) Die Volltextsuche sucht jeweils nur ein einzelnes Wort, benutzen Sie
lut_suche_multiple() zur Suche nach mehreren Worten</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_VOLLTEXT_SINGLE_WORD_ONLY</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT_SUCHE_INVALID_RSC-constant" class="">LUT_SUCHE_INVALID_RSC =
          <div class="docstring">
  <div class="discussion">
    
<p>(-117) die angegebene Suchresource ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT_SUCHE_INVALID_RSC</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT_SUCHE_INVALID_CMD-constant" class="">LUT_SUCHE_INVALID_CMD =
          <div class="docstring">
  <div class="discussion">
    
<p>(-116) bei der Suche sind im Verknüpfungsstring nur die Zeichen a-z sowie +
und - erlaubt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT_SUCHE_INVALID_CMD</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT_SUCHE_INVALID_CNT-constant" class="">LUT_SUCHE_INVALID_CNT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-115) bei der Suche müssen zwischen 1 und 26 Suchmuster angegeben werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT_SUCHE_INVALID_CNT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_VOLLTEXT_NOT_INITIALIZED-constant" class="">LUT2_VOLLTEXT_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-114) Das Feld Volltext wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_VOLLTEXT_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NO_OWN_IBAN_CALCULATION-constant" class="">NO_OWN_IBAN_CALCULATION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-113) das Institut erlaubt keine eigene IBAN-Berechnung</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NO_OWN_IBAN_CALCULATION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_UNSUPPORTED_COMPRESSION-constant" class="">KTO_CHECK_UNSUPPORTED_COMPRESSION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-112) die notwendige Kompressions-Bibliothek wurden beim Kompilieren nicht
eingebunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_UNSUPPORTED_COMPRESSION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_INVALID_COMPRESSION_LIB-constant" class="">KTO_CHECK_INVALID_COMPRESSION_LIB =
          <div class="docstring">
  <div class="discussion">
    
<p>(-111) der angegebene Wert für die Default-Kompression ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_INVALID_COMPRESSION_LIB</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_UNTERKONTO_ATTACHED_OLD-constant" class="">OK_UNTERKONTO_ATTACHED_OLD =
          <div class="docstring">
  <div class="discussion">
    
<p>(-110) (nicht mehr als Fehler, sondern positive Ausgabe - Dummy für den
alten Wert)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_UNTERKONTO_ATTACHED_OLD</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_DEFAULT_BLOCK_INVALID-constant" class="">KTO_CHECK_DEFAULT_BLOCK_INVALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(-109) Ungültige Signatur im Default-Block</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_DEFAULT_BLOCK_INVALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_DEFAULT_BLOCK_FULL-constant" class="">KTO_CHECK_DEFAULT_BLOCK_FULL =
          <div class="docstring">
  <div class="discussion">
    
<p>(-108) Die maximale Anzahl Einträge für den Default-Block wurde erreicht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_DEFAULT_BLOCK_FULL</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_NO_DEFAULT_BLOCK-constant" class="">KTO_CHECK_NO_DEFAULT_BLOCK =
          <div class="docstring">
  <div class="discussion">
    
<p>(-107) Es wurde noch kein Default-Block angelegt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_NO_DEFAULT_BLOCK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_KEY_NOT_FOUND-constant" class="">KTO_CHECK_KEY_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(-106) Der angegebene Schlüssel wurde im Default-Block nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_KEY_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_LONGER_VALID_BETTER-constant" class="">LUT2_NO_LONGER_VALID_BETTER =
          <div class="docstring">
  <div class="discussion">
    
<p>(-105) Beide Datensätze sind nicht mehr gültig, dieser ist aber jünger als
der andere</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_LONGER_VALID_BETTER</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_SRC_KTO_DIFFERENT-constant" class="">DTA_SRC_KTO_DIFFERENT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-104) Die Auftraggeber-Kontonummer des C-Datensatzes unterscheidet sich
von der des A-Satzes</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_SRC_KTO_DIFFERENT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_SRC_BLZ_DIFFERENT-constant" class="">DTA_SRC_BLZ_DIFFERENT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-103) Die Auftraggeber-Bankleitzahl des C-Datensatzes unterscheidet sich
von der des A-Satzes</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_SRC_BLZ_DIFFERENT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_CR_LF_IN_FILE-constant" class="">DTA_CR_LF_IN_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-102) Die DTA-Datei enthält (unzulässige) Zeilenvorschübe</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_CR_LF_IN_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_C_EXTENSION-constant" class="">DTA_INVALID_C_EXTENSION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-101) ungültiger Typ bei einem Erweiterungsblock eines C-Datensatzes</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_C_EXTENSION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FOUND_SET_A_NOT_C-constant" class="">DTA_FOUND_SET_A_NOT_C =
          <div class="docstring">
  <div class="discussion">
    
<p>(-100) Es wurde ein C-Datensatz erwartet, jedoch ein E-Satz gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FOUND_SET_A_NOT_C</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FOUND_SET_E_NOT_C-constant" class="">DTA_FOUND_SET_E_NOT_C =
          <div class="docstring">
  <div class="discussion">
    
<p>(-99) Es wurde ein C-Datensatz erwartet, jedoch ein E-Satz gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FOUND_SET_E_NOT_C</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FOUND_SET_C_NOT_EXTENSION-constant" class="">DTA_FOUND_SET_C_NOT_EXTENSION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-98) Es wurde ein C-Datensatzerweiterung erwartet, jedoch ein C-Satz
gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FOUND_SET_C_NOT_EXTENSION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FOUND_SET_E_NOT_EXTENSION-constant" class="">DTA_FOUND_SET_E_NOT_EXTENSION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-97) Es wurde ein C-Datensatzerweiterung erwartet, jedoch ein E-Satz
gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FOUND_SET_E_NOT_EXTENSION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_EXTENSION_COUNT-constant" class="">DTA_INVALID_EXTENSION_COUNT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-96) Die Anzahl Erweiterungen paßt nicht zur Blocklänge</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_EXTENSION_COUNT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_NUM-constant" class="">DTA_INVALID_NUM =
          <div class="docstring">
  <div class="discussion">
    
<p>(-95) Ungültige Zeichen in numerischem Feld</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_NUM</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_CHARS-constant" class="">DTA_INVALID_CHARS =
          <div class="docstring">
  <div class="discussion">
    
<p>(-94) Ungültige Zeichen im Textfeld</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_CHARS</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_CURRENCY_NOT_EURO-constant" class="">DTA_CURRENCY_NOT_EURO =
          <div class="docstring">
  <div class="discussion">
    
<p>(-93) Die Währung des DTA-Datensatzes ist nicht Euro</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_CURRENCY_NOT_EURO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_EMPTY_AMOUNT-constant" class="">DTA_EMPTY_AMOUNT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-92) In einem DTA-Datensatz wurde kein Betrag angegeben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_EMPTY_AMOUNT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_TEXT_KEY-constant" class="">DTA_INVALID_TEXT_KEY =
          <div class="docstring">
  <div class="discussion">
    
<p>(-91) Ungültiger Textschlüssel in der DTA-Datei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_TEXT_KEY</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_EMPTY_STRING-constant" class="">DTA_EMPTY_STRING =
          <div class="docstring">
  <div class="discussion">
    
<p>(-90) Für ein (alphanumerisches) Feld wurde kein Wert angegeben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_EMPTY_STRING</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_MARKER_A_NOT_FOUND-constant" class="">DTA_MARKER_A_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(-89) Die Startmarkierung des A-Datensatzes wurde nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_MARKER_A_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_MARKER_C_NOT_FOUND-constant" class="">DTA_MARKER_C_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(-88) Die Startmarkierung des C-Datensatzes wurde nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_MARKER_C_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_MARKER_E_NOT_FOUND-constant" class="">DTA_MARKER_E_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(-87) Die Startmarkierung des E-Datensatzes wurde nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_MARKER_E_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_SET_C_LEN-constant" class="">DTA_INVALID_SET_C_LEN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-86) Die Satzlänge eines C-Datensatzes muß zwischen 187 und 622 Byte
betragen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_SET_C_LEN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_SET_LEN-constant" class="">DTA_INVALID_SET_LEN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-85) Die Satzlänge eines A- bzw. E-Satzes muß 128 Byte betragen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_SET_LEN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_WAERUNG_NOT_EURO-constant" class="">DTA_WAERUNG_NOT_EURO =
          <div class="docstring">
  <div class="discussion">
    
<p>(-84) als Währung in der DTA-Datei ist nicht Euro eingetragen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_WAERUNG_NOT_EURO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_ISSUE_DATE-constant" class="">DTA_INVALID_ISSUE_DATE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-83) das Ausführungsdatum ist zu früh oder zu spät (max. 15 Tage nach
Dateierstellung)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_ISSUE_DATE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_INVALID_DATE-constant" class="">DTA_INVALID_DATE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-82) das Datum ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_INVALID_DATE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FORMAT_ERROR-constant" class="">DTA_FORMAT_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-81) Formatfehler in der DTA-Datei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FORMAT_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FILE_WITH_ERRORS-constant" class="">DTA_FILE_WITH_ERRORS =
          <div class="docstring">
  <div class="discussion">
    
<p>(-80) die DTA-Datei enthält Fehler</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FILE_WITH_ERRORS</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_SEARCH_RANGE-constant" class="">INVALID_SEARCH_RANGE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-79) ungültiger Suchbereich angegeben (unten&gt;oben)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_SEARCH_RANGE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KEY_NOT_FOUND-constant" class="">KEY_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(-78) Die Suche lieferte kein Ergebnis</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KEY_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="BAV_FALSE-constant" class="">BAV_FALSE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-77) BAV denkt, das Konto ist falsch (konto_check hält es für richtig)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>BAV_FALSE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_USER_BLOCK-constant" class="">LUT2_NO_USER_BLOCK =
          <div class="docstring">
  <div class="discussion">
    
<p>(-76) User-Blocks müssen einen Typ &gt; 500 haben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_USER_BLOCK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_SET-constant" class="">INVALID_SET =
          <div class="docstring">
  <div class="discussion">
    
<p>(-75) für ein LUT-Set sind nur die Werte 0, 1 oder 2 möglich</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_SET</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NO_GERMAN_BIC-constant" class="">NO_GERMAN_BIC =
          <div class="docstring">
  <div class="discussion">
    
<p>(-74) Ein Konto kann kann nur für deutsche Banken geprüft werden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NO_GERMAN_BIC</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IPI_CHECK_INVALID_LENGTH-constant" class="">IPI_CHECK_INVALID_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-73) Der zu validierende strukturierete Verwendungszweck muß genau 20
Zeichen enthalten</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IPI_CHECK_INVALID_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IPI_INVALID_CHARACTER-constant" class="">IPI_INVALID_CHARACTER =
          <div class="docstring">
  <div class="discussion">
    
<p>(-72) Im strukturierten Verwendungszweck dürfen nur alphanumerische Zeichen
vorkommen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IPI_INVALID_CHARACTER</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IPI_INVALID_LENGTH-constant" class="">IPI_INVALID_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-71) Die Länge des IPI-Verwendungszwecks darf maximal 18 Byte sein</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IPI_INVALID_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT1_FILE_USED-constant" class="">LUT1_FILE_USED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-70) Es wurde eine LUT-Datei im Format 1.0/1.1 geladen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT1_FILE_USED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="MISSING_PARAMETER-constant" class="">MISSING_PARAMETER =
          <div class="docstring">
  <div class="discussion">
    
<p>(-69) Für die aufgerufene Funktion fehlt ein notwendiger Parameter</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>MISSING_PARAMETER</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN2BIC_ONLY_GERMAN-constant" class="">IBAN2BIC_ONLY_GERMAN =
          <div class="docstring">
  <div class="discussion">
    
<p>(-68) Die Funktion iban2bic() arbeitet nur mit deutschen Bankleitzahlen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN2BIC_ONLY_GERMAN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="IBAN_OK_KTO_NOT-constant" class="">IBAN_OK_KTO_NOT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-67) Die Prüfziffer der IBAN stimmt, die der Kontonummer nicht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>IBAN_OK_KTO_NOT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_OK_IBAN_NOT-constant" class="">KTO_OK_IBAN_NOT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-66) Die Prüfziffer der Kontonummer stimmt, die der IBAN nicht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_OK_IBAN_NOT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="TOO_MANY_SLOTS-constant" class="">TOO_MANY_SLOTS =
          <div class="docstring">
  <div class="discussion">
    
<p>(-65) Es sind nur maximal 500 Slots pro LUT-Datei möglich (Neukompilieren
erforderlich)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>TOO_MANY_SLOTS</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INIT_FATAL_ERROR-constant" class="">INIT_FATAL_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-64) Initialisierung fehlgeschlagen (init_wait geblockt)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INIT_FATAL_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INCREMENTAL_INIT_NEEDS_INFO-constant" class="">INCREMENTAL_INIT_NEEDS_INFO =
          <div class="docstring">
  <div class="discussion">
    
<p>(-63) Ein inkrementelles Initialisieren benötigt einen Info-Block in der
LUT-Datei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INCREMENTAL_INIT_NEEDS_INFO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INCREMENTAL_INIT_FROM_DIFFERENT_FILE-constant" class="">INCREMENTAL_INIT_FROM_DIFFERENT_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-62) Ein inkrementelles Initialisieren mit einer anderen LUT-Datei ist
nicht möglich</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INCREMENTAL_INIT_FROM_DIFFERENT_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DEBUG_ONLY_FUNCTION-constant" class="">DEBUG_ONLY_FUNCTION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-61) Die Funktion ist nur in der Debug-Version vorhanden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DEBUG_ONLY_FUNCTION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_INVALID-constant" class="">LUT2_INVALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(-60) Kein Datensatz der LUT-Datei ist aktuell gültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_INVALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NOT_YET_VALID-constant" class="">LUT2_NOT_YET_VALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(-59) Der Datensatz ist noch nicht gültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NOT_YET_VALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_LONGER_VALID-constant" class="">LUT2_NO_LONGER_VALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(-58) Der Datensatz ist nicht mehr gültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_LONGER_VALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_GUELTIGKEIT_SWAPPED-constant" class="">LUT2_GUELTIGKEIT_SWAPPED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-57) Im Gültigkeitsdatum sind Anfangs- und Enddatum vertauscht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_GUELTIGKEIT_SWAPPED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_INVALID_GUELTIGKEIT-constant" class="">LUT2_INVALID_GUELTIGKEIT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-56) Das angegebene Gültigkeitsdatum ist ungültig (Sollformat ist
JJJJMMTT-JJJJMMTT)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_INVALID_GUELTIGKEIT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_INDEX_OUT_OF_RANGE-constant" class="">LUT2_INDEX_OUT_OF_RANGE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-55) Der Index für die Filiale ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_INDEX_OUT_OF_RANGE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_INIT_IN_PROGRESS-constant" class="">LUT2_INIT_IN_PROGRESS =
          <div class="docstring">
  <div class="discussion">
    
<p>(-54) Die Bibliothek wird gerade neu initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_INIT_IN_PROGRESS</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_BLZ_NOT_INITIALIZED-constant" class="">LUT2_BLZ_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-53) Das Feld BLZ wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_BLZ_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_FILIALEN_NOT_INITIALIZED-constant" class="">LUT2_FILIALEN_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-52) Das Feld Filialen wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_FILIALEN_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NAME_NOT_INITIALIZED-constant" class="">LUT2_NAME_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-51) Das Feld Bankname wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NAME_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_PLZ_NOT_INITIALIZED-constant" class="">LUT2_PLZ_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-50) Das Feld PLZ wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_PLZ_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_ORT_NOT_INITIALIZED-constant" class="">LUT2_ORT_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-49) Das Feld Ort wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_ORT_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NAME_KURZ_NOT_INITIALIZED-constant" class="">LUT2_NAME_KURZ_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-48) Das Feld Kurzname wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NAME_KURZ_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_PAN_NOT_INITIALIZED-constant" class="">LUT2_PAN_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-47) Das Feld PAN wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_PAN_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_BIC_NOT_INITIALIZED-constant" class="">LUT2_BIC_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-46) Das Feld BIC wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_BIC_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_PZ_NOT_INITIALIZED-constant" class="">LUT2_PZ_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-45) Das Feld Prüfziffer wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_PZ_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NR_NOT_INITIALIZED-constant" class="">LUT2_NR_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-44) Das Feld NR wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NR_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_AENDERUNG_NOT_INITIALIZED-constant" class="">LUT2_AENDERUNG_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-43) Das Feld Änderung wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_AENDERUNG_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_LOESCHUNG_NOT_INITIALIZED-constant" class="">LUT2_LOESCHUNG_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-42) Das Feld Löschung wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_LOESCHUNG_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NACHFOLGE_BLZ_NOT_INITIALIZED-constant" class="">LUT2_NACHFOLGE_BLZ_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-41) Das Feld Nachfolge-BLZ wurde nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NACHFOLGE_BLZ_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NOT_INITIALIZED-constant" class="">LUT2_NOT_INITIALIZED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-40) die Programmbibliothek wurde noch nicht initialisiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NOT_INITIALIZED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_FILIALEN_MISSING-constant" class="">LUT2_FILIALEN_MISSING =
          <div class="docstring">
  <div class="discussion">
    
<p>(-39) der Block mit der Filialenanzahl fehlt in der LUT-Datei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_FILIALEN_MISSING</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_PARTIAL_OK-constant" class="">LUT2_PARTIAL_OK =
          <div class="docstring">
  <div class="discussion">
    
<p>(-38) es wurden nicht alle Blocks geladen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_PARTIAL_OK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_Z_BUF_ERROR-constant" class="">LUT2_Z_BUF_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-37) Buffer error in den ZLIB Routinen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_Z_BUF_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_Z_MEM_ERROR-constant" class="">LUT2_Z_MEM_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-36) Memory error in den ZLIB-Routinen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_Z_MEM_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_Z_DATA_ERROR-constant" class="">LUT2_Z_DATA_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-35) Datenfehler im komprimierten LUT-Block</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_Z_DATA_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_BLOCK_NOT_IN_FILE-constant" class="">LUT2_BLOCK_NOT_IN_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-34) Der Block ist nicht in der LUT-Datei enthalten</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_BLOCK_NOT_IN_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_DECOMPRESS_ERROR-constant" class="">LUT2_DECOMPRESS_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-33) Fehler beim Dekomprimieren eines LUT-Blocks</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_DECOMPRESS_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_COMPRESS_ERROR-constant" class="">LUT2_COMPRESS_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-32) Fehler beim Komprimieren eines LUT-Blocks</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_COMPRESS_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_FILE_CORRUPTED-constant" class="">LUT2_FILE_CORRUPTED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-31) Die LUT-Datei ist korrumpiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_FILE_CORRUPTED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_SLOT_FREE-constant" class="">LUT2_NO_SLOT_FREE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-30) Im Inhaltsverzeichnis der LUT-Datei ist kein Slot mehr frei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_SLOT_FREE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="UNDEFINED_SUBMETHOD-constant" class="">UNDEFINED_SUBMETHOD =
          <div class="docstring">
  <div class="discussion">
    
<p>(-29) Die (Unter)Methode ist nicht definiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>UNDEFINED_SUBMETHOD</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="EXCLUDED_AT_COMPILETIME-constant" class="">EXCLUDED_AT_COMPILETIME =
          <div class="docstring">
  <div class="discussion">
    
<p>(-28) Der benötigte Programmteil wurde beim Kompilieren deaktiviert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>EXCLUDED_AT_COMPILETIME</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_LUT_VERSION-constant" class="">INVALID_LUT_VERSION =
          <div class="docstring">
  <div class="discussion">
    
<p>(-27) Die Versionsnummer für die LUT-Datei ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_LUT_VERSION</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_PARAMETER_STELLE1-constant" class="">INVALID_PARAMETER_STELLE1 =
          <div class="docstring">
  <div class="discussion">
    
<p>(-26) ungültiger Prüfparameter (erste zu prüfende Stelle)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_PARAMETER_STELLE1</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_PARAMETER_COUNT-constant" class="">INVALID_PARAMETER_COUNT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-25) ungültiger Prüfparameter (Anzahl zu prüfender Stellen)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_PARAMETER_COUNT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_PARAMETER_PRUEFZIFFER-constant" class="">INVALID_PARAMETER_PRUEFZIFFER =
          <div class="docstring">
  <div class="discussion">
    
<p>(-24) ungültiger Prüfparameter (Position der Prüfziffer)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_PARAMETER_PRUEFZIFFER</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_PARAMETER_WICHTUNG-constant" class="">INVALID_PARAMETER_WICHTUNG =
          <div class="docstring">
  <div class="discussion">
    
<p>(-23) ungültiger Prüfparameter (Wichtung)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_PARAMETER_WICHTUNG</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_PARAMETER_METHODE-constant" class="">INVALID_PARAMETER_METHODE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-22) ungültiger Prüfparameter (Rechenmethode)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_PARAMETER_METHODE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LIBRARY_INIT_ERROR-constant" class="">LIBRARY_INIT_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-21) Problem beim Initialisieren der globalen Variablen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LIBRARY_INIT_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT_CRC_ERROR-constant" class="">LUT_CRC_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-20) Prüfsummenfehler in der blz.lut Datei</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT_CRC_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FALSE_GELOESCHT-constant" class="">FALSE_GELOESCHT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-19) falsch (die BLZ wurde außerdem gelöscht)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FALSE_GELOESCHT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_NO_CHK_GELOESCHT-constant" class="">OK_NO_CHK_GELOESCHT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-18) ok, ohne Prüfung (die BLZ wurde allerdings gelöscht)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_NO_CHK_GELOESCHT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_GELOESCHT-constant" class="">OK_GELOESCHT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-17) ok (die BLZ wurde allerdings gelöscht)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_GELOESCHT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="BLZ_GELOESCHT-constant" class="">BLZ_GELOESCHT =
          <div class="docstring">
  <div class="discussion">
    
<p>(-16) die Bankleitzahl wurde gelöscht</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>BLZ_GELOESCHT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_BLZ_FILE-constant" class="">INVALID_BLZ_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-15) Fehler in der blz.txt Datei (falsche Zeilenlänge)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_BLZ_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LIBRARY_IS_NOT_THREAD_SAFE-constant" class="">LIBRARY_IS_NOT_THREAD_SAFE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-14) undefinierte Funktion, die library wurde mit THREAD_SAFE=0 kompiliert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LIBRARY_IS_NOT_THREAD_SAFE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FATAL_ERROR-constant" class="">FATAL_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-13) schwerer Fehler im Konto_check-Modul</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FATAL_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_KTO_LENGTH-constant" class="">INVALID_KTO_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-12) ein Konto muß zwischen 1 und 10 Stellen haben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_KTO_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FILE_WRITE_ERROR-constant" class="">FILE_WRITE_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-11) kann Datei nicht schreiben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FILE_WRITE_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FILE_READ_ERROR-constant" class="">FILE_READ_ERROR =
          <div class="docstring">
  <div class="discussion">
    
<p>(-10) kann Datei nicht lesen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FILE_READ_ERROR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="ERROR_MALLOC-constant" class="">ERROR_MALLOC =
          <div class="docstring">
  <div class="discussion">
    
<p>(-9) kann keinen Speicher allokieren</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ERROR_MALLOC</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NO_BLZ_FILE-constant" class="">NO_BLZ_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-8) die blz.txt Datei wurde nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NO_BLZ_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_LUT_FILE-constant" class="">INVALID_LUT_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-7) die blz.lut Datei ist inkosistent/ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_LUT_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NO_LUT_FILE-constant" class="">NO_LUT_FILE =
          <div class="docstring">
  <div class="discussion">
    
<p>(-6) die blz.lut Datei wurde nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NO_LUT_FILE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_BLZ_LENGTH-constant" class="">INVALID_BLZ_LENGTH =
          <div class="docstring">
  <div class="discussion">
    
<p>(-5) die Bankleitzahl ist nicht achtstellig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_BLZ_LENGTH</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_BLZ-constant" class="">INVALID_BLZ =
          <div class="docstring">
  <div class="discussion">
    
<p>(-4) die Bankleitzahl ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_BLZ</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_KTO-constant" class="">INVALID_KTO =
          <div class="docstring">
  <div class="discussion">
    
<p>(-3) das Konto ist ungültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>INVALID_KTO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NOT_IMPLEMENTED-constant" class="">NOT_IMPLEMENTED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-2) die Methode wurde noch nicht implementiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NOT_IMPLEMENTED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NOT_DEFINED-constant" class="">NOT_DEFINED =
          <div class="docstring">
  <div class="discussion">
    
<p>(-1) die Methode ist nicht definiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>NOT_DEFINED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FALSE-constant" class="">FALSE =
          <div class="docstring">
  <div class="discussion">
    
<p>(0) falsch</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>FALSE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK-constant" class="">OK =
          <div class="docstring">
  <div class="discussion">
    
<p>(1) ok</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_NO_CHK-constant" class="">OK_NO_CHK =
          <div class="docstring">
  <div class="discussion">
    
<p>(2) ok, ohne Prüfung</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_NO_CHK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_TEST_BLZ_USED-constant" class="">OK_TEST_BLZ_USED =
          <div class="docstring">
  <div class="discussion">
    
<p>(3) ok, für den Test wurde eine Test-BLZ verwendet</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_TEST_BLZ_USED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_VALID-constant" class="">LUT2_VALID =
          <div class="docstring">
  <div class="discussion">
    
<p>(4) Der Datensatz ist aktuell gültig</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_VALID</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_NO_VALID_DATE-constant" class="">LUT2_NO_VALID_DATE =
          <div class="docstring">
  <div class="discussion">
    
<p>(5) Der Datensatz enthält kein Gültigkeitsdatum</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_NO_VALID_DATE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT1_SET_LOADED-constant" class="">LUT1_SET_LOADED =
          <div class="docstring">
  <div class="discussion">
    
<p>(6) Die Datei ist im alten LUT-Format (1.0/1.1)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT1_SET_LOADED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT1_FILE_GENERATED-constant" class="">LUT1_FILE_GENERATED =
          <div class="docstring">
  <div class="discussion">
    
<p>(7) ok, es wurde allerdings eine LUT-Datei im alten Format (1.0/1.1)
generiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT1_FILE_GENERATED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="DTA_FILE_WITH_WARNINGS-constant" class="">DTA_FILE_WITH_WARNINGS =
          <div class="docstring">
  <div class="discussion">
    
<p>(8) In der DTAUS-Datei wurden kleinere Fehler gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>DTA_FILE_WITH_WARNINGS</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT_V2_FILE_GENERATED-constant" class="">LUT_V2_FILE_GENERATED =
          <div class="docstring">
  <div class="discussion">
    
<p>(9) ok, es wurde allerdings eine LUT-Datei im Format 2.0 generiert
(Compilerswitch)</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT_V2_FILE_GENERATED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="KTO_CHECK_VALUE_REPLACED-constant" class="">KTO_CHECK_VALUE_REPLACED =
          <div class="docstring">
  <div class="discussion">
    
<p>(10) ok, der Wert für den Schlüssel wurde überschrieben</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>KTO_CHECK_VALUE_REPLACED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_UNTERKONTO_POSSIBLE-constant" class="">OK_UNTERKONTO_POSSIBLE =
          <div class="docstring">
  <div class="discussion">
    
<p>(11) wahrscheinlich ok, die Kontonummer kann allerdings (nicht angegebene)
Unterkonten enthalten</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_UNTERKONTO_POSSIBLE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_UNTERKONTO_GIVEN-constant" class="">OK_UNTERKONTO_GIVEN =
          <div class="docstring">
  <div class="discussion">
    
<p>(12) wahrscheinlich ok, die Kontonummer enthält eine Unterkontonummer</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_UNTERKONTO_GIVEN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_SLOT_CNT_MIN_USED-constant" class="">OK_SLOT_CNT_MIN_USED =
          <div class="docstring">
  <div class="discussion">
    
<p>(13) ok, die Anzahl Slots wurde auf SLOT_CNT_MIN (60) hochgesetzt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_SLOT_CNT_MIN_USED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="SOME_KEYS_NOT_FOUND-constant" class="">SOME_KEYS_NOT_FOUND =
          <div class="docstring">
  <div class="discussion">
    
<p>(14) ok, ein(ige) Schlüssel wurden nicht gefunden</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>SOME_KEYS_NOT_FOUND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_KTO_NOT_CHECKED-constant" class="">LUT2_KTO_NOT_CHECKED =
          <div class="docstring">
  <div class="discussion">
    
<p>(15) Die Bankverbindung wurde nicht getestet</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_KTO_NOT_CHECKED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="LUT2_OK_WITHOUT_IBAN_RULES-constant" class="">LUT2_OK_WITHOUT_IBAN_RULES =
          <div class="docstring">
  <div class="discussion">
    
<p>(16) Es wurden fast alle Blocks (außer den IBAN-Regeln) geladen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>LUT2_OK_WITHOUT_IBAN_RULES</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_NACHFOLGE_BLZ_USED-constant" class="">OK_NACHFOLGE_BLZ_USED =
          <div class="docstring">
  <div class="discussion">
    
<p>(17) ok, für die BLZ wurde allerdings die Nachfolge-BLZ eingesetzt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_NACHFOLGE_BLZ_USED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_KTO_REPLACED-constant" class="">OK_KTO_REPLACED =
          <div class="docstring">
  <div class="discussion">
    
<p>(18) ok, die Kontonummer wurde allerdings ersetzt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_KTO_REPLACED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_BLZ_REPLACED-constant" class="">OK_BLZ_REPLACED =
          <div class="docstring">
  <div class="discussion">
    
<p>(19) ok, die Bankleitzahl wurde allerdings ersetzt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_BLZ_REPLACED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_BLZ_KTO_REPLACED-constant" class="">OK_BLZ_KTO_REPLACED =
          <div class="docstring">
  <div class="discussion">
    
<p>(20) ok, die Bankleitzahl und Kontonummer wurde allerdings ersetzt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_BLZ_KTO_REPLACED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_IBAN_WITHOUT_KC_TEST-constant" class="">OK_IBAN_WITHOUT_KC_TEST =
          <div class="docstring">
  <div class="discussion">
    
<p>(21) ok, die Bankverbindung ist (ohne Test) als richtig anzusehen</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_IBAN_WITHOUT_KC_TEST</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_INVALID_FOR_IBAN-constant" class="">OK_INVALID_FOR_IBAN =
          <div class="docstring">
  <div class="discussion">
    
<p>(22) ok, für IBAN ist (durch eine Regel) allerdings ein anderer BIC
definiert</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_INVALID_FOR_IBAN</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_HYPO_REQUIRES_KTO-constant" class="">OK_HYPO_REQUIRES_KTO =
          <div class="docstring">
  <div class="discussion">
    
<p>(23) ok, für die BIC-Bestimmung der ehemaligen Hypo-Bank für IBAN wird i.A.
zusätzlich die Kontonummer benötigt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_HYPO_REQUIRES_KTO</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_KTO_REPLACED_NO_PZ-constant" class="">OK_KTO_REPLACED_NO_PZ =
          <div class="docstring">
  <div class="discussion">
    
<p>(24) ok, die Kontonummer wurde ersetzt, die neue Kontonummer hat keine
Prüfziffer</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_KTO_REPLACED_NO_PZ</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="OK_UNTERKONTO_ATTACHED-constant" class="">OK_UNTERKONTO_ATTACHED =
          <div class="docstring">
  <div class="discussion">
    
<p>(25) ok, es wurde ein (weggelassenes) Unterkonto angefügt</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>OK_UNTERKONTO_ATTACHED</span><span class='rparen'>)</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_aenderung-class_method" title="bank_aenderung (class method)">+ (Object) <strong>bank_aenderung</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_aenderung%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_aenderung( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_aenderung%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_aenderung( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_alles-class_method" title="bank_alles (class method)">+ (Object) <strong>bank_alles</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_alles%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_alles( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_alles%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_alles( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_bic-class_method" title="bank_bic (class method)">+ (Object) <strong>bank_bic</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_bic%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_bic( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_bic%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_bic( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_filialen-class_method" title="bank_filialen (class method)">+ (Object) <strong>bank_filialen</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_filialen%28+blz%29">KontoCheckRaw::bank_filialen( blz)</h3>

<h5 id="label-KontoCheck%3A%3Abank_filialen%28+blz%29.">KontoCheck::bank_filialen( blz).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_loeschung-class_method" title="bank_loeschung (class method)">+ (Object) <strong>bank_loeschung</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_loeschung%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_loeschung( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_loeschung%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_loeschung( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_nachfolge_blz-class_method" title="bank_nachfolge_blz (class method)">+ (Object) <strong>bank_nachfolge_blz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_nachfolge_blz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_nachfolge_blz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_nachfolge_blz%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_nachfolge_blz( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_name-class_method" title="bank_name (class method)">+ (Object) <strong>bank_name</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_name%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_name( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_name%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_name( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_name_kurz-class_method" title="bank_name_kurz (class method)">+ (Object) <strong>bank_name_kurz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_name_kurz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_name_kurz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_name_kurz%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_name_kurz( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_nr-class_method" title="bank_nr (class method)">+ (Object) <strong>bank_nr</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_nr%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_nr( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_nr%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_nr( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_ort-class_method" title="bank_ort (class method)">+ (Object) <strong>bank_ort</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_ort%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_ort( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_ort%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_ort( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_pan-class_method" title="bank_pan (class method)">+ (Object) <strong>bank_pan</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_pan%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_pan( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_pan%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_pan( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_plz-class_method" title="bank_plz (class method)">+ (Object) <strong>bank_plz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_plz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_plz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_plz%28+blz+%5B%2Cfiliale%5D%29.">KontoCheck::bank_plz( blz [,filiale]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_pz-class_method" title="bank_pz (class method)">+ (Object) <strong>bank_pz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_pz%28+blz%29">KontoCheckRaw::bank_pz( blz)</h3>

<h5 id="label-KontoCheck%3A%3Abank_pz%28+blz%29.">KontoCheck::bank_pz( blz).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_bic-class_method" title="bank_suche_bic (class method)">+ (Object) <strong>bank_suche_bic</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_bic%28+search_bic+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_bic( search_bic [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_blz-class_method" title="bank_suche_blz (class method)">+ (Object) <strong>bank_suche_blz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_blz%28+blz1+%5B%2Cblz2+%5B%2Cuniq%5D%5D%29">KontoCheckRaw::bank_suche_blz( blz1 [,blz2 [,uniq]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_multiple-class_method" title="bank_suche_multiple (class method)">+ (Object) <strong>bank_suche_multiple</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_multiple%28+suchtext+%5B%2Csuch_cmd%5D+%5B%2Cuniq%5D%29">KontoCheckRaw::bank_suche_multiple( suchtext [,such_cmd] [,uniq])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_namen-class_method" title="bank_suche_namen (class method)">+ (Object) <strong>bank_suche_namen</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_namen%28+name+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_namen( name [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_namen_kurz-class_method" title="bank_suche_namen_kurz (class method)">+ (Object) <strong>bank_suche_namen_kurz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_namen_kurz%28+short_name+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_namen_kurz( short_name [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_ort-class_method" title="bank_suche_ort (class method)">+ (Object) <strong>bank_suche_ort</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_ort%28+suchort+%5B%2Cuniq%5D%29">KontoCheckRaw::bank_suche_ort( suchort [,uniq])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_plz-class_method" title="bank_suche_plz (class method)">+ (Object) <strong>bank_suche_plz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_plz%28+plz1+%5B%2Cplz2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_plz( plz1 [,plz2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_pz-class_method" title="bank_suche_pz (class method)">+ (Object) <strong>bank_suche_pz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_pz%28+pz1+%5B%2Cpz2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_pz( pz1 [,pz2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_regel-class_method" title="bank_suche_regel (class method)">+ (Object) <strong>bank_suche_regel</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_regel%28+regel1+%5B%2Cregel2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_regel( regel1 [,regel2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_suche_volltext-class_method" title="bank_suche_volltext (class method)">+ (Object) <strong>bank_suche_volltext</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_volltext%28+suchwort+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_volltext( suchwort [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29.">KontoCheck::suche().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bank_valid-class_method" title="bank_valid (class method)">+ (Object) <strong>bank_valid</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h4 id="label-KontoCheckRaw%3A%3Abank_valid%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_valid( blz [,filiale])</h4>

<h6 id="label-KontoCheck%3A%3Abank_valid%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_valid( blz [,filiale])</h6>

<h6 id="label-KontoCheck%3A%3Abank_valid%3F%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_valid?( blz [,filiale])</h6>

<p>Diese Funktion testet, ob eine gegebene BLZ gültig ist.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bic_check-class_method" title="bic_check (class method)">+ (Object) <strong>bic_check</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Abic_check%28+bic%29">KontoCheckRaw::bic_check( bic)</h3>

<h5 id="label-KontoCheck%3A%3Abic_check%28+bic%29">KontoCheck::bic_check( bic)</h5>

<p>Diese Funktion testet die Existenz eines (deutschen) BIC.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ci_check-class_method" title="ci_check (class method)">+ (Object) <strong>ci_check</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aci_check%28+ci%29">KontoCheckRaw::ci_check( ci)</h3>

<h5 id="label-KontoCheck%3A%3Aci_check%28+ci%29">KontoCheck::ci_check( ci)</h5>

<p>Diese Funktion testet eine Gläubiger-Identifikationsnummer (Credit
Identifier, ci).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#current_lutfile_name-class_method" title="current_lutfile_name (class method)">+ (Object) <strong>current_lutfile_name</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Acurrent_lutfile_name%28%29">KontoCheckRaw::current_lutfile_name()</h3>

<h5 id="label-KontoCheck%3A%3Acurrent_lutfile_name%28%29">KontoCheck::current_lutfile_name()</h5>

<h5 id="label-KontoCheck%3A%3Acurrent_lutfile_set%28%29">KontoCheck::current_lutfile_set()</h5>

<h5 id="label-KontoCheck%3A%3Acurrent_init_level%28%29.">KontoCheck::current_init_level().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dump_lutfile-class_method" title="dump_lutfile (class method)">+ (Object) <strong>dump_lutfile</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Adump_lutfile%28+lutfile%29">KontoCheckRaw::dump_lutfile( lutfile)</h3>

<h5 id="label-KontoCheck%3A%3Adump_lutfile%28+lutfile%29.">KontoCheck::dump_lutfile( lutfile).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding-class_method" title="encoding (class method)">+ (Object) <strong>encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aencoding%28+%5Bmode%5D%29">KontoCheckRaw::encoding( [mode])</h3>

<h5 id="label-KontoCheck%3A%3Aencoding%28+%5Bmode%5D%29">KontoCheck::encoding( [mode])</h5>

<h5 id="label-KontoCheckRaw%3A%3Aencoding_str%28+%5Bmode%5D%29">KontoCheckRaw::encoding_str( [mode])</h5>

<h5 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29.">KontoCheckRaw::keep_raw_data( mode).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding_str-class_method" title="encoding_str (class method)">+ (Object) <strong>encoding_str</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aencoding_str%28+mode%29">KontoCheckRaw::encoding_str( mode)</h3>

<h5 id="label-KontoCheck%3A%3Aencoding_str%28+mode%29">KontoCheck::encoding_str( mode)</h5>

<h5 id="label-KontoCheckRaw%3A%3Aencoding%28+mode%29">KontoCheckRaw::encoding( mode)</h5>

<h5 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29.">KontoCheckRaw::keep_raw_data( mode).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#free-class_method" title="free (class method)">+ (Object) <strong>free</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Afree%28%29">KontoCheckRaw::free()</h3>

<h5 id="label-KontoCheck%3A%3Afree%28%29.">KontoCheck::free().</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#generate_lutfile-class_method" title="generate_lutfile (class method)">+ (Object) <strong>generate_lutfile</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Agenerate_lutfile%28+inputfile%2Coutputfile+%5B%2Cuser_info+%5B%2Cgueltigkeit+%5B%2Cfelder+%5B%2Cfilialen+%5B%2Cset+%5B%2Ciban_file%5D%5D%5D%5D%5D%5D%29">KontoCheckRaw::generate_lutfile( inputfile,outputfile [,user_info [,gueltigkeit [,felder [,filialen [,set [,iban_file]]]]]])</h3>

<h5 id="label-KontoCheck%3A%3Agenerate_lutfile%28+inputfile%2Coutputfile+%5B%2Cuser_info+%5B%2Cgueltigkeit+%5B%2Cfelder+%5B%2Cfilialen+%5B%2Cset+%5B%2Ciban_file%5D%5D%5D%5D%5D%5D%29.">KontoCheck::generate_lutfile( inputfile,outputfile [,user_info [,gueltigkeit [,felder [,filialen [,set [,iban_file]]]]]]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#iban2bic-class_method" title="iban2bic (class method)">+ (Object) <strong>iban2bic</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aiban2bic%28+iban%29">KontoCheckRaw::iban2bic( iban)</h3>

<h5 id="label-KontoCheck%3A%3Aiban2bic%28+iban%29.">KontoCheck::iban2bic( iban).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#iban_check-class_method" title="iban_check (class method)">+ (Object) <strong>iban_check</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aiban_check%28+iban%29">KontoCheckRaw::iban_check( iban)</h3>

<h5 id="label-KontoCheck%3A%3Aiban_check%28+iban%29">KontoCheck::iban_check( iban)</h5>

<p>Diese Funktion testet eine IBAN; bei deutschen Bankverbindungen wird
zusätzlich noch die Plausibilität der Bankverbindung getestet und im
Statuswert zurückgegeben.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#iban_gen-class_method" title="iban_gen (class method)">+ (Object) <strong>iban_gen</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aiban_gen%28+blz%2Ckto%29">KontoCheckRaw::iban_gen( blz,kto)</h3>

<h5 id="label-KontoCheck%3A%3Aiban_gen%28+kto%2Cblz%29">KontoCheck::iban_gen( kto,blz)</h5>

<p>Diese Funktion generiert aus (deutscher) BLZ und Konto einen IBAN, sowie
den zugehörigen BIC.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#init-class_method" title="init (class method)">+ (Object) <strong>init</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Ainit%28+%5Bp1+%5B%2Cp2+%5B%2Cset%5D%5D%5D%29">KontoCheckRaw::init( [p1 [,p2 [,set]]])</h3>

<h5 id="label-KontoCheck%3A%3Ainit%28+%5Bp1+%5B%2Cp2+%5B%2Cset%5D%5D%5D%29">KontoCheck::init( [p1 [,p2 [,set]]])</h5>

<p>Diese Funktion initialisiert die Bibliothek und lädt die gewünschten
Datenblocks in den Speicher.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipi_check-class_method" title="ipi_check (class method)">+ (Object) <strong>ipi_check</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aipi_check%28+zweck%29">KontoCheckRaw::ipi_check( zweck)</h3>

<h5 id="label-KontoCheck%3A%3Aipi_check%28+zweck%29.">KontoCheck::ipi_check( zweck).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipi_gen-class_method" title="ipi_gen (class method)">+ (Object) <strong>ipi_gen</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aipi_gen%28+zweck%29">KontoCheckRaw::ipi_gen( zweck)</h3>

<h5 id="label-KontoCheck%3A%3Aipi_gen%28+zweck%29.">KontoCheck::ipi_gen( zweck).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#keep_raw_data-class_method" title="keep_raw_data (class method)">+ (Object) <strong>keep_raw_data</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29">KontoCheckRaw::keep_raw_data( mode)</h3>

<h5 id="label-KontoCheckRaw%3A%3Aencoding%28+mode%29">KontoCheckRaw::encoding( mode)</h5>

<h5 id="label-KontoCheck%3A%3Aencoding%28+mode%29.">KontoCheck::encoding( mode).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#konto_check-class_method" title="konto_check (class method)">+ (Object) <strong>konto_check</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Akonto_check%28+blz%2C+kto%29">KontoCheckRaw::konto_check( blz, kto)</h3>

<h5 id="label-KontoCheck%3A%3Akonto_check%28+blz%2C+kto%29">KontoCheck::konto_check( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#konto_check_pz-class_method" title="konto_check_pz (class method)">+ (Object) <strong>konto_check_pz</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_pz%28+pz%2C+kto+%5B%2Cblz%5D%29">KontoCheckRaw::konto_check_pz( pz, kto [,blz])</h3>

<h5 id="label-KontoCheck%3A%3Akonto_check_pz%28+pz%2C+kto+%5B%2Cblz%5D%29.">KontoCheck::konto_check_pz( pz, kto [,blz]).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#konto_check_regel-class_method" title="konto_check_regel (class method)">+ (Object) <strong>konto_check_regel</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel( blz, kto)</h3>

<h5 id="label-KontoCheckRaw%3A%3Akonto_check_regel_dbg%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel_dbg( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheck::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%3F%28+blz%2C+kto%29">KontoCheck::konto_check_regel?( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#konto_check_regel_dbg-class_method" title="konto_check_regel_dbg (class method)">+ (Object) <strong>konto_check_regel_dbg</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_regel_dbg%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel_dbg( blz, kto)</h3>

<h5 id="label-KontoCheckRaw%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheck::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%3F%28+blz%2C+kto%29">KontoCheck::konto_check_regel?( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#load_bank_data-class_method" title="load_bank_data (class method)">+ (Object) <strong>load_bank_data</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aload_bank_data%28+datafile%29">KontoCheckRaw::load_bank_data( datafile)</h3>

<h5 id="label-KontoCheck%3A%3Aload_bank_data%28+datafile%29.">KontoCheck::load_bank_data( datafile).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lut_blocks-class_method" title="lut_blocks (class method)">+ (Object) <strong>lut_blocks</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Alut_blocks%28+mode%29">KontoCheckRaw::lut_blocks( mode)</h3>

<h5 id="label-KontoCheck%3A%3Alut_blocks%28+mode%29">KontoCheck::lut_blocks( mode)</h5>

<p>Die Funktion gibt Auskunft, ob bei der Initialisierung alle angeforderten
Blocks der LUT-Datei geladen wurden und gibt den Dateinamen der LUT-Datei,
eine Liste der geladenen Blocks sowie eine Liste der Blocks die nicht
geladen werden konnten, zurück.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lut_blocks1-class_method" title="lut_blocks1 (class method)">+ (Object) <strong>lut_blocks1</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Alut_blocks1%28+%29">KontoCheckRaw::lut_blocks1( )</h3>

<h5 id="label-KontoCheckRaw%3A%3Alut_blocks%28+mode%29">KontoCheckRaw::lut_blocks( mode)</h5>

<h5 id="label-KontoCheck%3A%3Alut_blocks%28+%29">KontoCheck::lut_blocks( )</h5>

<p>Diese Funktion entspricht weitgehend der Funktion lut_blocks(); sie gibt
allerdings nur den Statuscode zurück, keine Strings.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lut_info-class_method" title="lut_info (class method)">+ (Object) <strong>lut_info</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Alut_info%28+%5Blutfile%5D%29">KontoCheckRaw::lut_info( [lutfile])</h3>

<h5 id="label-KontoCheck%3A%3Alut_info%28%29">KontoCheck::lut_info()</h5>

<h5 id="label-KontoCheck%3A%3Alut_info1%28+lutfile%29">KontoCheck::lut_info1( lutfile)</h5>

<h5 id="label-KontoCheck%3A%3Alut_info2%28+lutfile%29.">KontoCheck::lut_info2( lutfile).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2dos-class_method" title="retval2dos (class method)">+ (Object) <strong>retval2dos</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2dos%28+retval%29">KontoCheckRaw::retval2dos( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2dos%28+retval%29.">KontoCheck::retval2dos( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2html-class_method" title="retval2html (class method)">+ (Object) <strong>retval2html</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2html%28+retval%29">KontoCheckRaw::retval2html( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2html%28+retval%29.">KontoCheck::retval2html( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2iso-class_method" title="retval2iso (class method)">+ (Object) <strong>retval2iso</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2iso%28+retval%29">KontoCheckRaw::retval2iso( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2iso%28+retval%29.">KontoCheck::retval2iso( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2txt-class_method" title="retval2txt (class method)">+ (Object) <strong>retval2txt</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2txt%28+retval%29">KontoCheckRaw::retval2txt( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2txt%28+retval%29.">KontoCheck::retval2txt( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2txt_short-class_method" title="retval2txt_short (class method)">+ (Object) <strong>retval2txt_short</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2txt_short%28+retval%29">KontoCheckRaw::retval2txt_short( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2txt_short%28+retval%29.">KontoCheck::retval2txt_short( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#retval2utf8-class_method" title="retval2utf8 (class method)">+ (Object) <strong>retval2utf8</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aretval2utf8%28+retval%29">KontoCheckRaw::retval2utf8( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2utf8%28+retval%29.">KontoCheck::retval2utf8( retval).</h5>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#version-class_method" title="version (class method)">+ (Object) <strong>version</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<h3 id="label-KontoCheckRaw%3A%3Aversion%28+%5Bmode%5D+%29">KontoCheckRaw::version( [mode] )</h3>

<h5 id="label-KontoCheck%3A%3Aversion%28+%5Bmode%5D+%29.">KontoCheck::version( [mode] ).</h5>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="bank_aenderung-class_method">
  
    + (<tt>Object</tt>) <strong>bank_aenderung</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_aenderung%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_aenderung( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_aenderung%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_aenderung( blz [,filiale])</h5>

<p>Diese Funktion liefert das  ‘Änderung’ Flag einer Bank (als string).
Mögliche Werte sind: A (Addition), M (Modified), U (Unchanged), D
(Deletion). Der Rückgabewert ist ein Array mit zwei Elementen: im ersten
steht ein String mit dem Änderungsflag, im zweiten ein Statuscode. Im
Fehlerfall wird für das Flag nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-43  (LUT2_AENDERUNG_NOT_INITIALIZED) “Das Feld Änderung wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2274
2275
2276
2277
2278
2279
2280
2281
2282
2283
2284</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2274</span>

static VALUE bank_aenderung(int argc,VALUE* argv,VALUE self)
{
   char blz[16],aenderung[2],error_msg[512];
   int retval,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   *aenderung=lut_aenderung(blz,filiale,&amp;retval);
   aenderung[1]=0;
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_AENDERUNG_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:rb_str_new2(aenderung),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_alles-class_method">
  
    + (<tt>Object</tt>) <strong>bank_alles</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_alles%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_alles( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_alles%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_alles( blz [,filiale])</h5>

<p>Dies ist eine Mammutfunktion, die alle vorhandenen Informationen über eine
Bank zurückliefert. Das Ergebnis ist ein Array mit den folgenden
Komponenten:</p>
<ul><li>
<p>0:  Statuscode</p>
</li><li>
<p>1:  Anzahl Filialen</p>
</li><li>
<p>2:  Name</p>
</li><li>
<p>3:  Kurzname</p>
</li><li>
<p>4:  PLZ</p>
</li><li>
<p>5:  Ort</p>
</li><li>
<p>6:  PAN</p>
</li><li>
<p>7:  BIC</p>
</li><li>
<p>8:  Prüfziffer</p>
</li><li>
<p>9:  Laufende Nr.</p>
</li><li>
<p>10: Änderungs-Flag</p>
</li><li>
<p>11: Löeschung-Flag</p>
</li><li>
<p>12: Nachfolge-BLZ</p>
</li></ul>

<p>Der Statuscode (Element 0) kann folgende Werte annehmen:</p>
<ul><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-38  (LUT2_PARTIAL_OK)            “es wurden nicht alle Blocks geladen”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)         “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>

<p>* Anmerkung: Falls der Statuscode LUT2_PARTIAL_OK ist, wurden bei der
Initialisierung nicht alle Blocks geladen (oder es sind nicht alle
verfügbar); die entsprechenden Elemente haben dann den Wert nil.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2038</span>

static VALUE bank_alles(int argc,VALUE* argv,VALUE self)
{
   char blz[16],**p_name,**p_name_kurz,**p_ort,**p_bic,*p_aenderung,*p_loeschung,aenderung[2],loeschung[2],error_msg[512];
   int retval,filiale,cnt,*p_blz,*p_plz,*p_pan,p_pz,*p_nr,*p_nachfolge_blz;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   retval=lut_multiple(blz,&amp;cnt,&amp;p_blz, &amp;p_name,&amp;p_name_kurz,&amp;p_plz,&amp;p_ort,&amp;p_pan,&amp;p_bic,&amp;p_pz,&amp;p_nr,
         &amp;p_aenderung,&amp;p_loeschung,&amp;p_nachfolge_blz,NULL,NULL,NULL);
   if(retval==LUT2_BLZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   if(filiale&lt;0 || (cnt &amp;&amp; filiale&gt;=cnt))return(INT2FIX(LUT2_INDEX_OUT_OF_RANGE));  /* ungültige Filiale */

      /* Fehler; die C-Arrays dürfen in diesem Fall nicht dereferenziert werden */
   if(retval&lt;=0 &amp;&amp; retval!=LUT2_PARTIAL_OK)return rb_ary_new3(2,INT2FIX(retval),Qnil);

   if(p_aenderung){
      *aenderung=p_aenderung[filiale];
      *(aenderung+1)=0;
   }
   else
      *aenderung=0;

   if(p_loeschung){
      *loeschung=p_loeschung[filiale];
      *(loeschung+1)=0;
   }
   else
      *loeschung=0;

   /* Makros für StringValue und IntegerValue definieren, damit die Rückgabe
    * einigermaßen übersichtlich bleibt
    */
#define SV(x) *x?rb_str_new2(x):Qnil
#define IV(x) x&gt;=0?INT2FIX(x):Qnil
   return rb_ary_new3(13,INT2FIX(retval),IV(cnt),SV(p_name[filiale]),
         SV(p_name_kurz[filiale]),IV(p_plz[filiale]),SV(p_ort[filiale]),
         IV(p_pan[filiale]),SV(p_bic[filiale]),IV(p_pz),IV(p_nr[filiale]),
         SV(aenderung),SV(loeschung),IV(p_nachfolge_blz[filiale]));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_bic-class_method">
  
    + (<tt>Object</tt>) <strong>bank_bic</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_bic%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_bic( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_bic%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_bic( blz [,filiale])</h5>

<p>Diese Funktion liefert den BIC (Bank Identifier Code) einer Bank. Der
Rückgabewert ist ein Array mit zwei Elementen: im ersten steht ein String
mit dem BIC, im zweiten ein Statuscode. Im Fehlerfall wird für den BIC nil
zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-46  (LUT2_BIC_NOT_INITIALIZED)      “Das Feld BIC wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2243</span>

static VALUE bank_bic(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   const char *ptr;
   int retval,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   ptr=lut_bic(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_BIC_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:rb_str_new2(ptr),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_filialen-class_method">
  
    + (<tt>Object</tt>) <strong>bank_filialen</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_filialen%28+blz%29">KontoCheckRaw::bank_filialen( blz)</h3>

<h5 id="label-KontoCheck%3A%3Abank_filialen%28+blz%29">KontoCheck::bank_filialen( blz)</h5>

<p>Diese Funktion liefert die Anzahl Filialen einer Bank (inklusive
Hauptstelle). Die LUT-Datei muß dazu natürlich mit den Filialdaten
generiert sein, sonst wird für alle Banken nur 1 zurückgegeben. Der
Rückgabewert ist ein Array mit der Anzahl Filialen im ersten Parameter, und
einem Statuscode im zwweiten.</p>

<p>Mögliche Statuswerte sind:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-52  (LUT2_FILIALEN_NOT_INITIALIZED) “Das Feld Filialen wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1994
1995
1996
1997
1998
1999
2000
2001
2002
2003</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1994</span>

static VALUE bank_filialen(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,cnt;

   get_params(argc,argv,blz,NULL,NULL,NULL,0);
   cnt=lut_filialen(blz,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_FILIALEN_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(cnt),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_loeschung-class_method">
  
    + (<tt>Object</tt>) <strong>bank_loeschung</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_loeschung%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_loeschung( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_loeschung%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_loeschung( blz [,filiale])</h5>

<p>Diese Funktion liefert das Lösch-Flag für eine Bank zurück (als Integer;
mögliche Werte sind 0 und 1). Der Rückgabewert ist ein Array mit zwei
Elementen: im ersten steht das Flag, im zweiten ein Statuscode. Im
Fehlerfall wird für das Flag nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-42  (LUT2_LOESCHUNG_NOT_INITIALIZED) “Das Feld Löschung wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2304
2305
2306
2307
2308
2309
2310
2311
2312
2313</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2304</span>

static VALUE bank_loeschung(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,loeschung,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   loeschung=lut_loeschung(blz,filiale,&amp;retval)-'0';
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_LOESCHUNG_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(loeschung),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_nachfolge_blz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_nachfolge_blz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_nachfolge_blz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_nachfolge_blz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_nachfolge_blz%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_nachfolge_blz( blz [,filiale])</h5>

<p>Diese Funktion liefert die Nachfolge-BLZ für eine Bank, die gelöscht werden
soll (bei der das ‘Löschung’ Flag 1 ist). Der Rückgabewert ist ein Array
mit zwei Elementen: im ersten steht die Nachfolge-BLZ, im zweiten ein
Statuscode. Im Fehlerfall wird für die Nachfolge-BLZ nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-41  (LUT2_NACHFOLGE_BLZ_NOT_INITIALIZED) “Das Feld Nachfolge-BLZ wurde
nicht initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2333
2334
2335
2336
2337
2338
2339
2340
2341
2342</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2333</span>

static VALUE bank_nachfolge_blz(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,n_blz,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   n_blz=lut_nachfolge_blz(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_NACHFOLGE_BLZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(n_blz),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_name-class_method">
  
    + (<tt>Object</tt>) <strong>bank_name</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_name%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_name( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_name%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_name( blz [,filiale])</h5>

<p>Diese Funktion liefert den Namen einer Bank. Der Rückgabewert ist ein Array
mit zwei Elementen: im ersten steht ein String mit dem Namen, im zweiten
ein Statuscode. Im Fehlerfall wird für den Namen nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-51  (LUT2_NAME_NOT_INITIALIZED)     “Das Feld Bankname wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2094</span>

static VALUE bank_name(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   const char *name;
   int retval,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   name=lut_name(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_NAME_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:rb_str_new2(name),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_name_kurz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_name_kurz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_name_kurz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_name_kurz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_name_kurz%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_name_kurz( blz [,filiale])</h5>

<p>Diese Funktion liefert den Kurznamen einer Bank. Der Rückgabewert ist ein
Array mit zwei Elementen: im ersten steht ein String mit dem Namen, im
zweiten ein Statuscode. Im Fehlerfall wird für den Namen nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-48  (LUT2_NAME_KURZ_NOT_INITIALIZED) “Das Feld Kurzname wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2123
2124
2125
2126
2127
2128
2129
2130
2131
2132
2133</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2123</span>

static VALUE bank_name_kurz(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   const char *name;
   int retval,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   name=lut_name_kurz(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_NAME_KURZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:rb_str_new2(name),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_nr-class_method">
  
    + (<tt>Object</tt>) <strong>bank_nr</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_nr%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_nr( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_nr%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_nr( blz [,filiale])</h5>

<p>Diese Funktion liefert die laufende Nummer einer Bank (internes Feld der
BLZ-Datei). Der Wert wird wahrscheinlich nicht oft benötigt, ist aber der
Vollständigkeit halber enthalten. Der Rückgabewert ist ein Array mit zwei
Elementen: im ersten steht die Nummer, im zweiten ein Statuscode. Im
Fehlerfall wird für die Nummer nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>

<p>Possible return values (and short description):</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-44  (LUT2_NR_NOT_INITIALIZED)       “Das Feld NR wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2393
2394
2395
2396
2397
2398
2399
2400
2401
2402</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2393</span>

static VALUE bank_nr(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,nr,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   nr=lut_nr(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_NR_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(nr),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_ort-class_method">
  
    + (<tt>Object</tt>) <strong>bank_ort</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_ort%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_ort( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_ort%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_ort( blz [,filiale])</h5>

<p>Diese Funktion liefert den Ort einer Bank. Falls der Parameter filiale
nicht angegeben ist, wird der Sitz der Hauptstelle ausgegeben. Der
Rückgabewert ist ein Array mit zwei Elementen: im ersten steht ein String
mit dem Namen, im zweiten ein Statuscode. Im Fehlerfall wird für den Ort
nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)   “Das Feld BLZ wurde nicht initialisiert”</p>
</li><li>
<p>-49  (LUT2_ORT_NOT_INITIALIZED)   “Das Feld Ort wurde nicht initialisiert”</p>
</li><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)    “Der Index für die Filiale ist ungültig”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)         “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2154</span>

static VALUE bank_ort(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   const char *ort;
   int retval,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   ort=lut_ort(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_ORT_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:rb_str_new2(ort),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_pan-class_method">
  
    + (<tt>Object</tt>) <strong>bank_pan</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_pan%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_pan( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_pan%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_pan( blz [,filiale])</h5>

<p>Diese Funktion liefert den PAN (Primary Account Number) einer Bank. Der
Rückgabewert ist ein Array mit zwei Elementen: im ersten steht der PAN, im
zweiten ein Statuscode. Im Fehlerfall wird für den PAN nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-47  (LUT2_PAN_NOT_INITIALIZED)      “Das Feld PAN wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2361
2362
2363
2364
2365
2366
2367
2368
2369
2370</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2361</span>

static VALUE bank_pan(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,pan,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   pan=lut_pan(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_PAN_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(pan),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_plz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_plz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_plz%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_plz( blz [,filiale])</h3>

<h5 id="label-KontoCheck%3A%3Abank_plz%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_plz( blz [,filiale])</h5>

<p>Diese Funktion liefert die Postleitzahl einer Bank. Falls der Parameter
filiale nicht angegeben ist, wird die PLZ der Hauptstelle ausgegeben. Der
Rückgabewert ist ein Array mit zwei Elementen: im ersten steht die PLZ, im
zweiten ein Statuscode. Im Fehlerfall wird für die PLZ nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-50  (LUT2_PLZ_NOT_INITIALIZED)      “Das Feld PLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2184
2185
2186
2187
2188
2189
2190
2191
2192
2193</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2184</span>

static VALUE bank_plz(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,plz,filiale;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   plz=lut_plz(blz,filiale,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_PLZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(plz),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_pz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_pz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_pz%28+blz%29">KontoCheckRaw::bank_pz( blz)</h3>

<h5 id="label-KontoCheck%3A%3Abank_pz%28+blz%29">KontoCheck::bank_pz( blz)</h5>

<p>Diese Funktion liefert die Prüfziffer einer Bank. Die Funktion unterstützt
keine Filialen; zu jeder BLZ kann es in der LUT-Datei nur eine
Prüfziffermethode geben. Der Rückgabewert ist ein Array mit zwei Elementen:
im ersten steht die Prüfziffer, im zweiten ein Statuscode. Im Fehlerfall
wird für den Prüfziffer nil zurückgegeben.</p>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)       “Der Index für die Filiale ist
ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)      “Das Feld BLZ wurde nicht
initialisiert”</p>
</li><li>
<p>-45  (LUT2_PZ_NOT_INITIALIZED)       “Das Feld Prüfziffer wurde nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)            “die Bankleitzahl ist nicht
achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                   “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                            “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2214
2215
2216
2217
2218
2219
2220
2221
2222
2223</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2214</span>

static VALUE bank_pz(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int retval,pz;

   get_params(argc,argv,blz,NULL,NULL,NULL,0);
   pz=lut_pz(blz,0,&amp;retval);
   if(retval==LUT2_BLZ_NOT_INITIALIZED || retval==LUT2_PZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return rb_ary_new3(2,retval&lt;=0?Qnil:INT2FIX(pz),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_bic-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_bic</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_bic%28+search_bic+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_bic( search_bic [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren BIC mit dem angegebenen Wert
&lt;search_bic&gt; beginnen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen BIC-Werten</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-46  (LUT2_BIC_NOT_INITIALIZED)   “Das Feld BIC wurde nicht initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2568
2569
2570
2571</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2568</span>

static VALUE bank_suche_bic(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,lut_suche_bic,NULL);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_blz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_blz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_blz%28+blz1+%5B%2Cblz2+%5B%2Cuniq%5D%5D%29">KontoCheckRaw::bank_suche_blz( blz1 [,blz2 [,uniq]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren Bankleitzahl gleich &lt;blz1&gt;
ist oder (bei Angabe von blz2) die im Bereich zwischen &lt;blz1&gt; und
&lt;blz2&gt; liegen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Bankleitzahlen</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen (bei dieser Funktion doppelt gemoppelt :-) )</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)   “Das Feld BLZ wurde nicht initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2706
2707
2708
2709</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2706</span>

static VALUE bank_suche_blz(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,NULL,lut_suche_blz);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_multiple-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_multiple</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_multiple%28+suchtext+%5B%2Csuch_cmd%5D+%5B%2Cuniq%5D%29">KontoCheckRaw::bank_suche_multiple( suchtext [,such_cmd] [,uniq])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, die mehreren Kriterien entsprechen. Dabei
können bis zu 26 Teilsuchen definiert werden, die beliebig miteinander
verknüpft werden können (additiv, subtraktiv und multiplikativ).</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>result=bank_suche_multiple(such_string [,such_cmd] [,uniq])</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>such_string: Dieser Parameter gibt die Felder an, nach denen gesucht wird.
Er besteht aus einem oder mehreren Suchbefehlen, die jeweils folgenden
Aufbau haben: [<a href="http://@suchfeld">such_index:]suchwert</a></p>

<p>Der (optionale) Suchindex ist ein Buchstabe von a-z, mit dem das Suchfeld
im Suchkommando (zweiter Parameter) referenziert werden kann. Falls er
nicht angegeben wird, erhält der erste Suchstring den Index a, der zweite
den Index b etc.</p>

<p>Der Suchwert ist der Wert nach dem gesucht werden soll. Für die Textfelder
ist es der Beginn des Wortes (aa passt z.B. auf Aach, Aachen, Aalen,
Aarbergen), für numerische Felder kann es eine Zahl oder ein Zahlbereich in
der Form 22-33 sein.</p>

<p>Das Suchfeld gibt an, nach welchem Feld der BLZ-Datei gesucht werden soll.
Falls das Suchfeld nicht angegeben wird, wird eine Volltextsuche (alle
Einzelworte in Name, Kurzname und Ort) gemacht. Die folgende Werte sind
möglich:</p>

<pre class="code"><code><span class='id identifier rubyid_bl'>bl</span>    <span class='const'>BLZ</span>
<span class='id identifier rubyid_bi'>bi</span>    <span class='const'>BIC</span>
<span class='id identifier rubyid_k'>k</span>     <span class='const'>Kurzname</span>
<span class='id identifier rubyid_n'>n</span>     <span class='const'>Name</span>
<span class='id identifier rubyid_o'>o</span>     <span class='const'>Ort</span>
<span class='id identifier rubyid_pl'>pl</span>    <span class='const'>PLZ</span>
<span class='id identifier rubyid_pr'>pr</span>    <span class='const'>Prüfziffer</span>
<span class='id identifier rubyid_pz'>pz</span>    <span class='const'>Prüfziffer</span>
<span class='id identifier rubyid_v'>v</span>     <span class='const'>Volltext</span></code></pre>

<p>In der obigen Tabelle der Suchfelder sind nur die Kurzversionen angegeben;
eine Angabe wie aa@ort oder 57000-58000@plz ist auch problemlos möglich.</p>
</li><li>
<p>such_cmd: Dieser Parameter gibt an, wie die Teilsuchen miteinander
verknüpft werden sollen. Der Ausdruck abc bedeutet, daß die BLZs in den
Teilsuchen a, b und c enthalten sein müssen; der Ausdruck a+b+c, daß sie in
mindestens einer Teilsuche enthalten sein muß; der Ausdruck a-b, daß sie in
a, aber nicht in b enthalten sein darf (Beispiel s.u.). Falls das
Suchkommando nicht angegeben wird, müssen die Ergebnis-BLZs in allen
Teilsuchen enthalten sein.</p>
</li><li>
<p>uniq: Falls dieser Parameter 0 ist, werden alle gefundenen Zweigstellen
ausgegeben; falls er 1 ist, wird für jede Bank nur eine Zweigstelle
ausgegeben. Die Ausgabe ist (anders als bei den anderen Suchroutinen,
bedingt durch die Arbeitsweise der Funktion) immer nach BLZ sortiert. Falls
der Parameter weggelassen wird, wird der Standardwert für uniq aus
konto_check.h benutzt.</p>
</li></ul>

<h4 id="label-Beispiele%3A">Beispiele:</h4>
<ul><li>
<p>ret=KontoCheckRaw::bank_suche_multiple( “b:55000000-55100000@blz
o:67000-68000@plz sparkasse”,“bo”) Bei diesem Aufruf werden nur die beiden
ersten Teilsuchen (nach BLZ und PLZ) benutzt; die Suche findet alle Banken
mit einer BLZ zwischen 55000000 und 55100000 im PLZ-Bereich 67000 bis
68000.</p>
</li><li>
<p>ret=KontoCheckRaw::bank_suche_multiple( “b:55000000-55030000@blz
o:67000-68000@plz sparkasse”,“co”) Ähnlicher Aufruf wie oben, allerdings
werden nur die beiden letzten Teilsuchen berücksichtigt.</p>
</li><li>
<p>ret=KontoCheckRaw::bank_suche_multiple( “67000-68000@plz sparda”,0) Dieser
Aufruf gibt alle Filialen der Sparda-Bank im PLZ-Bereich 67000 bis 68000
zurück.</p>
</li><li>
<p>ret=KontoCheckRaw::bank_suche_multiple( “skat”) Dieser Aufruf ist einfach
eine Volltextsuche nach der Skat-Bank. Der direkte Aufruf von
bank_suche_volltext() ist intern natürlich wesentlich leichtgewichtiger,
aber die Suche so auch möglich.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist immer nil (nur für Kompatibilität mit den anderen
Suchfunktionen)</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-48  (LUT2_NAME_KURZ_NOT_INITIALIZED) “Das Feld Kurzname wurde nicht
initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li><li>
<p>14  (SOME_KEYS_NOT_FOUND)        “ok; ein(ige) Schlüssel wurden nicht
gefunden”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2933</span>

static VALUE bank_suche_multiple(int argc,VALUE* argv,VALUE self)
{
   char such_text[1280],such_cmd[256],error_msg[512];
   int i,retval,uniq;
   UINT4 *blz,*zweigstelle,anzahl;
   VALUE ret_blz,ret_idx;

   get_params(argc,argv,such_text,such_cmd,NULL,&amp;uniq,6);
   retval=lut_suche_multiple(such_text,uniq&gt;1,such_cmd,&amp;anzahl,&amp;zweigstelle,&amp;blz);
   if(retval==KEY_NOT_FOUND || !anzahl)return rb_ary_new3(5,Qnil,Qnil,Qnil,INT2FIX(retval),INT2FIX(0));
   if(retval&lt;0)RUNTIME_ERROR(retval);
   ret_blz=rb_ary_new2(anzahl);
   ret_idx=rb_ary_new2(anzahl);
   for(i=0;i&lt;(int)anzahl;i++){
      rb_ary_store(ret_blz,i,INT2FIX(blz[i]));
      rb_ary_store(ret_idx,i,INT2FIX(zweigstelle[i]));
   }
   kc_free((char*)blz);
   kc_free((char*)zweigstelle);
   return rb_ary_new3(5,Qnil,ret_blz,ret_idx,INT2FIX(retval),INT2FIX(anzahl));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_namen-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_namen</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_namen%28+name+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_namen( name [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren Namen mit dem angegebenen Wert
&lt;name&gt; beginnen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Namen</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-51  (LUT2_NAME_NOT_INITIALIZED)  “Das Feld Bankname wurde nicht
initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2595
2596
2597
2598</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2595</span>

static VALUE bank_suche_namen(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,lut_suche_namen,NULL);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_namen_kurz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_namen_kurz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_namen_kurz%28+short_name+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_namen_kurz( short_name [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren Kurznamen mit dem angegebenen Wert
&lt;search_bic&gt; beginnen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Kurznamen</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-48  (LUT2_NAME_KURZ_NOT_INITIALIZED) “Das Feld Kurzname wurde nicht
initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2622
2623
2624
2625</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2622</span>

static VALUE bank_suche_namen_kurz(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,lut_suche_namen_kurz,NULL);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_ort-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_ort</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_ort%28+suchort+%5B%2Cuniq%5D%29">KontoCheckRaw::bank_suche_ort( suchort [,uniq])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren Sitz mit dem angegebenen Wert
&lt;suchort&gt; beginnen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Orten</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-49  (LUT2_ORT_NOT_INITIALIZED)   “Das Feld Ort wurde nicht initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2733
2734
2735
2736</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2733</span>

static VALUE bank_suche_ort(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,lut_suche_ort,NULL);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_plz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_plz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_plz%28+plz1+%5B%2Cplz2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_plz( plz1 [,plz2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren PLZ gleich &lt;plz1&gt; ist oder
(bei Angabe von plz2) die im Bereich zwischen &lt;plz1&gt; und &lt;plz2&gt;
liegen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Postleitzahlen</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-50  (LUT2_PLZ_NOT_INITIALIZED)   “Das Feld PLZ wurde nicht initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2650
2651
2652
2653</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2650</span>

static VALUE bank_suche_plz(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,NULL,lut_suche_plz);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_pz-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_pz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_pz%28+pz1+%5B%2Cpz2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_pz( pz1 [,pz2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren Prüfziffer gleich &lt;pz1&gt; ist
oder (bei Angabe von pz2) die im Bereich zwischen &lt;pz1&gt; und
&lt;pz2&gt; liegen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Prüfziffern</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-45  (LUT2_PZ_NOT_INITIALIZED)    “Das Feld Prüfziffer wurde nicht
initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2678
2679
2680
2681</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2678</span>

static VALUE bank_suche_pz(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,NULL,lut_suche_pz);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_regel-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_regel</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_regel%28+regel1+%5B%2Cregel2+%5B%2Csort_uniq+%5B%2Csort%5D%5D%5D%29">KontoCheckRaw::bank_suche_regel( regel1 [,regel2 [,sort_uniq [,sort]]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, deren IBAN-Regel gleich &lt;regel1&gt;
ist oder (bei Angabe von regel2) die im Bereich zwischen &lt;regel1&gt; und
&lt;regel2&gt; liegen. Die Rückgabe ist ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Regeln</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-45  (LUT2_PZ_NOT_INITIALIZED)    “Das Feld Prüfziffer wurde nicht
initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2761
2762
2763
2764</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2761</span>

static VALUE bank_suche_regel(int argc,VALUE* argv,VALUE self)
{
   return bank_suche_int(argc,argv,self,NULL,lut_suche_regel);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_suche_volltext-class_method">
  
    + (<tt>Object</tt>) <strong>bank_suche_volltext</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abank_suche_volltext%28+suchwort+%5B%2Csort_uniq+%5B%2Csort%5D%5D%29">KontoCheckRaw::bank_suche_volltext( suchwort [,sort_uniq [,sort]])</h3>

<h5 id="label-KontoCheck%3A%3Asuche%28%29">KontoCheck::suche()</h5>

<p>Diese Funktion sucht alle Banken, bei denen in Name, Kurzname oder Ort das
angegebenen Wort &lt;suchwort&gt; vorkommt. Dabei wird immer nur ein
einziges Wort gesucht; falls mehrere Worte angegeben werden, wird der
Fehlerwert LUT2_VOLLTEXT_SINGLE_WORD_ONLY zurückgegeben. Die Rückgabe ist
ein Array mit fünf Elementen:</p>
<ul><li>
<p>Das erste Element ist ein Array mit den gefundenen Suchworten</p>
</li><li>
<p>Das zweite Element ist ein Array mit den Bankleitzahlen, die auf das
Suchmuster passen</p>
</li><li>
<p>Das dritte Element ist ein Array mit den Zweigstellen-Indizes der
gefundenen Bankleitzahlen</p>
</li><li>
<p>das vierte Element ist der Statuscode (s.u.)</p>
</li><li>
<p>das fünfte Element gibt die Anzahl der gefundenen Banken zurück.</p>
</li></ul>

<p>Mögliche Statuscodes:</p>
<ul><li>
<p>-118  (LUT2_VOLLTEXT_SINGLE_WORD_ONLY) “Die Volltextsuche sucht jeweils nur
ein einzelnes Wort; benutzen Sie bank_suche_multiple() zur Suche nach
mehreren Worten”</p>
</li><li>
<p>-114  (LUT2_VOLLTEXT_NOT_INITIALIZED)  “Das Feld Volltext wurde nicht
initialisiert”</p>
</li><li>
<p>-78  (KEY_NOT_FOUND)              “Die Suche lieferte kein Ergebnis”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2792</span>

static VALUE bank_suche_volltext(int argc,VALUE* argv,VALUE self)
{
   char such_wort[128],**base_name,error_msg[512];
   int i,j,k,retval,anzahl,anzahl2,last_blz,uniq,*start_idx,*zweigstelle,*blz_base,base_name_idx,zweigstellen_anzahl;
   int *idx_o,*cnt_o;
   VALUE ret_blz,ret_idx,ret_suche;

   get_params(argc,argv,such_wort,NULL,NULL,&amp;uniq,7);
   retval=lut_suche_volltext(such_wort,&amp;anzahl,&amp;base_name_idx,&amp;base_name,&amp;zweigstellen_anzahl,&amp;start_idx,&amp;zweigstelle,&amp;blz_base);
   if(retval==KEY_NOT_FOUND)return rb_ary_new3(5,Qnil,Qnil,Qnil,INT2FIX(retval),INT2FIX(0));
   if(retval&lt;0)RUNTIME_ERROR(retval);
   ret_suche=rb_ary_new2(anzahl);

      /* base_name ist hier komplett unabhängig von den Bankleitzahlen; auch
       * die Größe der beiden Arrays stimmt nicht überein!!! Daher müssen
       * die gefundenen Volltexte in einer eigenen Schleife gespeichert werden.
       */
   for(i=0;i&lt;anzahl;i++){  /* gefundene Volltexte zurückgeben */
      j=base_name_idx+i;
      rb_ary_store(ret_suche,i,rb_str_new2(base_name[j]));
   }
      /* die Anzahl der BLZs steht in der Variablen zweigstellen_anzahl */
   if(uniq) /* bei uniq&gt;0 sortieren, uniq&gt;1 sortieren + uniq */
      lut_suche_sort1(zweigstellen_anzahl,blz_base,zweigstelle,start_idx,&amp;anzahl2,&amp;idx_o,&amp;cnt_o,uniq&gt;1);
   else{
      anzahl2=zweigstellen_anzahl;
      idx_o=start_idx;
      cnt_o=NULL;
   }
   ret_blz=rb_ary_new2(anzahl2);
   ret_idx=rb_ary_new2(anzahl2);
   for(i=k=0,last_blz=-1;i&lt;anzahl2;i++){
      j=idx_o[i];   /* Index innerhalb der BLZ-Datei */
      if(uniq&gt;1 &amp;&amp; blz_base[j]==last_blz)
         continue;
      else
         last_blz=blz_base[j];
      rb_ary_store(ret_blz,k,INT2FIX(blz_base[j]));
      rb_ary_store(ret_idx,k++,INT2FIX(zweigstelle[j]));
   }
   if(uniq){
      kc_free((char*)idx_o);
      kc_free((char*)cnt_o);
   }
   return rb_ary_new3(5,ret_suche,ret_blz,ret_idx,INT2FIX(retval),INT2FIX(anzahl2));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bank_valid-class_method">
  
    + (<tt>Object</tt>) <strong>bank_valid</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h4 id="label-KontoCheckRaw%3A%3Abank_valid%28+blz+%5B%2Cfiliale%5D%29">KontoCheckRaw::bank_valid( blz [,filiale])</h4>

<h6 id="label-KontoCheck%3A%3Abank_valid%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_valid( blz [,filiale])</h6>

<h6 id="label-KontoCheck%3A%3Abank_valid%3F%28+blz+%5B%2Cfiliale%5D%29">KontoCheck::bank_valid?( blz [,filiale])</h6>

<p>Diese Funktion testet, ob eine gegebene BLZ gültig ist. Der Rückgabewert
ist ein Statuscode mit den unten angegebenen Werten. Falls das Argument
filiale auch angegeben ist, wird zusätzlich noch getestet, ob eine Filiale
mit dem gegebenen Index existiert.</p>

<p>Mögliche Rückgabewerte sind:</p>
<ul><li>
<p>-55  (LUT2_INDEX_OUT_OF_RANGE)    “Der Index für die Filiale ist ungültig”</p>
</li><li>
<p>-53  (LUT2_BLZ_NOT_INITIALIZED)   “Das Feld BLZ wurde nicht initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)         “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1963
1964
1965
1966
1967
1968
1969
1970
1971
1972</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1963</span>

static VALUE bank_valid(int argc,VALUE* argv,VALUE self)
{
   char blz[16],error_msg[512];
   int filiale,retval;

   get_params(argc,argv,blz,NULL,NULL,&amp;filiale,1);
   retval=lut_blz(blz,filiale);
   if(retval==LUT2_BLZ_NOT_INITIALIZED)RUNTIME_ERROR(retval);
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="bic_check-class_method">
  
    + (<tt>Object</tt>) <strong>bic_check</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Abic_check%28+bic%29">KontoCheckRaw::bic_check( bic)</h3>

<h5 id="label-KontoCheck%3A%3Abic_check%28+bic%29">KontoCheck::bic_check( bic)</h5>

<p>Diese Funktion testet die Existenz eines (deutschen) BIC. Die Rückgabe ist
ein Array mit zwei Elementen: im ersten (retval) wird das Testergebnis für
die zurückgegeben, im zweiten die Änzahl Banken, die diesen BIC benutzen.
Der BIC muß mit genau 8 oder 11 Stellen angegeben werden. Intern wird dabei
die Funktion lut_suche_bic() verwendet.</p>

<p>Die Funktion arbeitet nur für deutsche Banken, da für andere keine Infos
vorliegen.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::bic_check( bic)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>bic: der bic, der getestet werden soll</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Array mit zwei Elementen:</p>
<ul><li>
<p>das erste Element enthält den Statuscode</p>
</li><li>
<p>das zweite Element enthält die Anzahl Banken, die diesen BIC benutzen</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+R%C3%BCckgabewerte%3A">Mögliche Rückgabewerte:</h4>
<ul><li>
<p>-145  (BIC_ONLY_GERMAN)         “Es werden nur deutsche BICs unterstützt”;</p>
</li><li>
<p>-144  (INVALID_BIC_LENGTH)      “Die Länge des BIC muß genau 8 oder 11
Zeichen sein”</p>
</li><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1807
1808
1809
1810
1811
1812
1813
1814
1815</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1807</span>

static VALUE bic_check_rb(int argc,VALUE* argv,VALUE self)
{
   char bic[12];
   int retval,cnt;

   get_params(argc,argv,bic,NULL,NULL,NULL,8);
   retval=bic_check(bic,&amp;cnt);
   return rb_ary_new3(2,INT2FIX(retval),INT2FIX(cnt));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ci_check-class_method">
  
    + (<tt>Object</tt>) <strong>ci_check</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aci_check%28+ci%29">KontoCheckRaw::ci_check( ci)</h3>

<h5 id="label-KontoCheck%3A%3Aci_check%28+ci%29">KontoCheck::ci_check( ci)</h5>

<p>Diese Funktion testet eine Gläubiger-Identifikationsnummer (Credit
Identifier, ci)</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::ci_check( ci)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>ci: der CI, der getestet werden soll</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+R%C3%BCckgabewerte+f%C3%BCr+den+Test%3A">Mögliche Rückgabewerte für den Test:</h4>
<ul><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1769
1770
1771
1772
1773
1774
1775</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1769</span>

static VALUE ci_check_rb(int argc,VALUE* argv,VALUE self)
{
   char ci[128];

   get_params(argc,argv,ci,NULL,NULL,NULL,3);
   return INT2FIX(ci_check(ci));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="current_lutfile_name-class_method">
  
    + (<tt>Object</tt>) <strong>current_lutfile_name</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Acurrent_lutfile_name%28%29">KontoCheckRaw::current_lutfile_name()</h3>

<h5 id="label-KontoCheck%3A%3Acurrent_lutfile_name%28%29">KontoCheck::current_lutfile_name()</h5>

<h5 id="label-KontoCheck%3A%3Acurrent_lutfile_set%28%29">KontoCheck::current_lutfile_set()</h5>

<h5 id="label-KontoCheck%3A%3Acurrent_init_level%28%29">KontoCheck::current_init_level()</h5>

<p>Diese Funktion bestimmt den Dateinamen der zur Initialisierung benutzen
LUT-Datei, das benutzte Set und den Initialisierungslevel der aktuellen
Initialisierung.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval=KontoCheckRaw::current_lutfile_name</p>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabewert ist ein Array mit vier Elementen: das erste ist der Dateiname
der LUT-Datei, das zweite  das benutzte Set (0, falls nicht initialisiert
wurde, sonst 1 oder 2), das dritte der Initialisierungslevel und das vierte
der Statuscode.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


949
950
951
952
953
954
955
956
957
958
959
960</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 949</span>

static VALUE current_lutfile_name_rb(VALUE self)
{
   const char *lut_filename;
   int set,level,retval;
   VALUE lut_filename_rb;

   if(!(lut_filename=current_lutfile_name(&amp;set,&amp;level,&amp;retval)))
      lut_filename_rb=Qnil;
   else
      lut_filename_rb=rb_str_new2(lut_filename);
   return rb_ary_new3(4,lut_filename_rb,INT2FIX(set),INT2FIX(level),INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="dump_lutfile-class_method">
  
    + (<tt>Object</tt>) <strong>dump_lutfile</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Adump_lutfile%28+lutfile%29">KontoCheckRaw::dump_lutfile( lutfile)</h3>

<h5 id="label-KontoCheck%3A%3Adump_lutfile%28+lutfile%29">KontoCheck::dump_lutfile( lutfile)</h5>

<p>Diese Funktion liefert detaillierte Informationen über alle Blocks, die in
der LUT-Datei gespeichert sind, sowie noch einige Internas der LUT-Datei.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval=KontoCheckRaw::dump_lutfile( lutfile)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>lutfile: Name der LUT-Datei.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Der Rückgabewert ist ein Array mit zwei Elementen: im ersten steht ein
String mit den Infos, im zweiten ein Statuscode. Im Fehlerfall wird für den
Infostring nil zurückgegeben.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-112  (KTO_CHECK_UNSUPPORTED_COMPRESSION) “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)             “Es wurde eine LUT-Datei im Format
1.0/1.1 geladen”</p>
</li><li>
<p>-36  (LUT2_Z_MEM_ERROR)           “Memory error in den ZLIB-Routinen”</p>
</li><li>
<p>-35  (LUT2_Z_DATA_ERROR)          “Datenfehler im komprimierten LUT-Block”</p>
</li><li>
<p>-33  (LUT2_DECOMPRESS_ERROR)      “Fehler beim Dekomprimieren eines
LUT-Blocks”</p>
</li><li>
<p>-31  (LUT2_FILE_CORRUPTED)        “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-20  (LUT_CRC_ERROR)              “Prüfsummenfehler in der blz.lut Datei”</p>
</li><li>
<p>-10  (FILE_READ_ERROR)            “kann Datei nicht lesen”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  (INVALID_LUT_FILE)           “die blz.lut Datei ist
inkosistent/ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1479</span>

static VALUE dump_lutfile_rb(int argc,VALUE* argv,VALUE self)
{
   char lut_name[FILENAME_MAX+1],*ptr;
   int retval;
   VALUE dump;

   get_params_file(argc,argv,lut_name,NULL,NULL,2);
   retval=lut_dir_dump_str(lut_name,&amp;ptr);
   if(retval&lt;=0)
      dump=Qnil;
   else
      dump=rb_str_new2(ptr);
   kc_free(ptr);  /* die C-Funktion allokiert Speicher, der muß wieder freigegeben werden */
   return rb_ary_new3(2,dump,INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="encoding-class_method">
  
    + (<tt>Object</tt>) <strong>encoding</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aencoding%28+%5Bmode%5D%29">KontoCheckRaw::encoding( [mode])</h3>

<h5 id="label-KontoCheck%3A%3Aencoding%28+%5Bmode%5D%29">KontoCheck::encoding( [mode])</h5>

<h5 id="label-KontoCheckRaw%3A%3Aencoding_str%28+%5Bmode%5D%29">KontoCheckRaw::encoding_str( [mode])</h5>

<h5 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29">KontoCheckRaw::keep_raw_data( mode)</h5>

<p>Diese Funktion legt den benutzten Zeichensatz für Fehlermeldungen durch die
Funktion KontoCheckRaw::retval2txt() und einige Felder der LUT-Datei (Name,
Kurzname, Ort) fest. Wenn die Funktion nicht aufgerufen wird, wird der Wert
DEFAULT_ENCODING aus konto_check.h benutzt.</p>

<p><em>Achtung</em>: Das Verhalten der Funktion hängt von dem Flag
keep_raw_data der C-Bibliothek ab. Falls das Flag gesetzt ist, werden die
Rohdaten der Blocks Name, Kurzname und Ort im Speicher gehalten; bei einem
Wechsel der Kodierung wird auch für diese Blocks die Kodierung umgesetzt.
Falls das Flag nicht gesetzt ist, sollte die Funktion <strong>vor</strong>
der Initialisierung aufgerufen werden, da in dem Fall die Daten der
LUT-Datei nur bei der Initialisierung konvertiert werden. Mit der Funktion
KontoCheckRaw::keep_raw_data() kann das Flag gesetzt gelöscht und abgefragt
werden.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>KontoCheckRaw::encoding( [mode])</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>mode: die gewünschte Kodierung. Falls der Parameter nicht angegeben wird,
wird die aktuelle Kodierung zurückgegeben. Ansonsten werden für den
Parameter mode die folgenden Werte akzeptiert (die Strings sind nicht case
sensitiv; Mi oder mI oder MI ist z.B. auch möglich.</p>
</li><li>
<p>0:            aktuelle Kodierung ausgeben</p>
</li><li>
<p>1,  ‘i’, ‘I’: ISO-8859-1</p>
</li><li>
<p>2,  ‘u’, ‘U’: UTF-8</p>
</li><li>
<p>3,  ‘h’, ‘H’: HTML</p>
</li><li>
<p>4,  ‘d’, ‘D’: DOS CP 850</p>
</li><li>
<p>51, ‘mi’:     ISO-8859-1, Makro für Fehlermeldungen</p>
</li><li>
<p>52, ‘mu’:     UTF-8, Makro für Fehlermeldungen</p>
</li><li>
<p>53, ‘mh’:     HTML, Makro für Fehlermeldungen</p>
</li><li>
<p>54, ‘md’:     DOS CP 850, Makro für Fehlermeldungen</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabewert ist die aktuelle Kodierung als Integer (falls zwei Kodierungen
angegeben sind, ist die erste die der Statusmeldungen, die zweite die der
LUT-Blocks):</p>
<ul><li>
<p>0:  “noch nicht spezifiziert” (vor der Initialisierung)</p>
</li><li>
<p>1:  “ISO-8859-1”;</p>
</li><li>
<p>2:  “UTF-8”;</p>
</li><li>
<p>3:  “HTML entities”;</p>
</li><li>
<p>4:  “DOS CP 850”;</p>
</li><li>
<p>12: “ISO-8859-1/UTF-8”;</p>
</li><li>
<p>13: “ISO-8859-1/HTML”;</p>
</li><li>
<p>14: “ISO-8859-1/DOS CP 850”;</p>
</li><li>
<p>21: “UTF-8/ISO-8859-1”;</p>
</li><li>
<p>23: “UTF-8/HTML”;</p>
</li><li>
<p>24: “UTF-8/DOS CP-850”;</p>
</li><li>
<p>31: “HTML entities/ISO-8859-1”;</p>
</li><li>
<p>32: “HTML entities/UTF-8”;</p>
</li><li>
<p>34: “HTML entities/DOS CP-850”;</p>
</li><li>
<p>41: “DOS CP-850/ISO-8859-1”;</p>
</li><li>
<p>42: “DOS CP-850/UTF-8”;</p>
</li><li>
<p>43: “DOS CP-850/HTML”;</p>
</li><li>
<p>51: “Makro/ISO-8859-1”;</p>
</li><li>
<p>52: “Makro/UTF-8”;</p>
</li><li>
<p>53: “Makro/HTML”;</p>
</li><li>
<p>54: “Makro/DOS CP 850”;</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1227
1228
1229
1230</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1227</span>

static VALUE encoding_rb(int argc,VALUE* argv,VALUE self)
{
   return INT2FIX(kto_check_encoding(enc_mode(argc,argv)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="encoding_str-class_method">
  
    + (<tt>Object</tt>) <strong>encoding_str</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aencoding_str%28+mode%29">KontoCheckRaw::encoding_str( mode)</h3>

<h5 id="label-KontoCheck%3A%3Aencoding_str%28+mode%29">KontoCheck::encoding_str( mode)</h5>

<h5 id="label-KontoCheckRaw%3A%3Aencoding%28+mode%29">KontoCheckRaw::encoding( mode)</h5>

<h5 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29">KontoCheckRaw::keep_raw_data( mode)</h5>

<p>Diese Funktion entspricht der Funktion KontoCheck::encoding(). Allerdings
ist der Rückgabewert nicht numerisch, sondern ein String, der die aktuelle
Kodierung angibt.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>KontoCheckRaw::encoding_str( [mode])</p>

<h4 id="label-Parameter%3A">Parameter:</h4>

<p>wie bei KontoCheckRaw::encoding()</p>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabewert ist die aktuelle Kodierung als String:</p>
<ul><li>
<p>“noch nicht spezifiziert” (vor der Initialisierung)</p>
</li><li>
<p>“ISO-8859-1”;</p>
</li><li>
<p>“UTF-8”;</p>
</li><li>
<p>“HTML entities”;</p>
</li><li>
<p>“DOS CP 850”;</p>
</li><li>
<p>“ISO-8859-1/UTF-8”;</p>
</li><li>
<p>“ISO-8859-1/HTML”;</p>
</li><li>
<p>“ISO-8859-1/DOS CP 850”;</p>
</li><li>
<p>“UTF-8/ISO-8859-1”;</p>
</li><li>
<p>“UTF-8/HTML”;</p>
</li><li>
<p>“UTF-8/DOS CP-850”;</p>
</li><li>
<p>“HTML entities/ISO-8859-1”;</p>
</li><li>
<p>“HTML entities/UTF-8”;</p>
</li><li>
<p>“HTML entities/DOS CP-850”;</p>
</li><li>
<p>“DOS CP-850/ISO-8859-1”;</p>
</li><li>
<p>“DOS CP-850/UTF-8”;</p>
</li><li>
<p>“DOS CP-850/HTML”;</p>
</li><li>
<p>“Makro/ISO-8859-1”;</p>
</li><li>
<p>“Makro/UTF-8”;</p>
</li><li>
<p>“Makro/HTML”;</p>
</li><li>
<p>“Makro/DOS CP 850”;</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1273
1274
1275
1276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1273</span>

static VALUE encoding_str_rb(int argc,VALUE* argv,VALUE self)
{
   return rb_str_new2((kto_check_encoding_str(enc_mode(argc,argv))));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="free-class_method">
  
    + (<tt>Object</tt>) <strong>free</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Afree%28%29">KontoCheckRaw::free()</h3>

<h5 id="label-KontoCheck%3A%3Afree%28%29">KontoCheck::free()</h5>

<p>Diese Funktion gibt allen allokierten Speicher wieder frei. Der
Rückgabewert ist immer true.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


968
969
970
971
972</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 968</span>

static VALUE free_rb(VALUE self)
{
   lut_cleanup();
   return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="generate_lutfile-class_method">
  
    + (<tt>Object</tt>) <strong>generate_lutfile</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Agenerate_lutfile%28+inputfile%2Coutputfile+%5B%2Cuser_info+%5B%2Cgueltigkeit+%5B%2Cfelder+%5B%2Cfilialen+%5B%2Cset+%5B%2Ciban_file%5D%5D%5D%5D%5D%5D%29">KontoCheckRaw::generate_lutfile( inputfile,outputfile [,user_info [,gueltigkeit [,felder [,filialen [,set [,iban_file]]]]]])</h3>

<h5 id="label-KontoCheck%3A%3Agenerate_lutfile%28+inputfile%2Coutputfile+%5B%2Cuser_info+%5B%2Cgueltigkeit+%5B%2Cfelder+%5B%2Cfilialen+%5B%2Cset+%5B%2Ciban_file%5D%5D%5D%5D%5D%5D%29">KontoCheck::generate_lutfile( inputfile,outputfile [,user_info [,gueltigkeit [,felder [,filialen [,set [,iban_file]]]]]])</h5>

<p>Diese Funktion generiert eine neue LUT-Datei aus der BLZ-Datei der
Deutschen Bundesbank. Die folgenden Parameter werden unterstützt:</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>inputfile: Eingabedatei (Textdatei) der Bundesbank</p>
</li><li>
<p>outputfile: Name der Ausgabedatei</p>
</li><li>
<p>user_info: Info-String der in die LUT-Datei geschrieben wird (frei wählbar;
wird in den Info-Block aufgenommen)</p>
</li><li>
<p>gueltigkeit: Gültigkeit des Datensatzes im Format JJJJMMTT-JJJJMMTT. Diese
Angabe wird benutzt, um festzustellen, ob ein Datensatz aktuell noch gültig
ist.</p>
</li><li>
<p>felder: (0-9) Welche Daten aufgenommmen werden sollen (PZ steht in der
folgenden Tabelle für Prüfziffer, NAME_NAME_KURZ ist ein Block, der sowohl
den Namen als auch den Kurznamen der Bank enthält; dieser läßt sich besser
komprimieren als wenn beide Blocks getrennt sind):</p>

<pre class="code"><code>0. BLZ,PZ
1. BLZ,PZ,NAME_KURZ
2. BLZ,PZ,NAME_KURZ,BIC
3. BLZ,PZ,NAME,PLZ,ORT
4. BLZ,PZ,NAME,PLZ,ORT,BIC
5. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC
6. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ
7. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,
   AENDERUNG
8. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,
   AENDERUNG,LOESCHUNG
9. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,
   AENDERUNG,LOESCHUNG,PAN,NR</code></pre>
</li><li>
<p>filialen: (0 oder 1) Flag, ob nur die Daten der Hauptstellen (0) oder auch
die der Filialen aufgenommen werden sollen</p>
</li><li>
<p>set (0, 1 oder 2): Datensatz-Nummer. Jede LUT-Datei kann zwei Datensätze
enthalten. Falls bei der Initialisierung nicht ein bestimmter Datensatz
ausgewählt wird, wird derjenige genommen, der (laut Gültigkeitsstring)
aktuell gültig ist. Bei 0 wird eine neue LUT-Datei generiert, bei 1 oder 2
wird der entsprechende Datensatz angehängt.</p>
</li><li>
<p>iban_blacklist: Datei der Banken, die einer Selbstberechnung des IBAN nicht
zugestimmt haben. Näheres dazu (inklusive Weblink) findet sich bei der
Funktion KontoCheckRaw::iban_gen(blz,kto).</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-112  (KTO_CHECK_UNSUPPORTED_COMPRESSION) “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-57  (LUT2_GUELTIGKEIT_SWAPPED)   “Im Gültigkeitsdatum sind Anfangs- und
Enddatum vertauscht”</p>
</li><li>
<p>-56  (LUT2_INVALID_GUELTIGKEIT)   “Das angegebene Gültigkeitsdatum ist
ungültig (Soll: JJJJMMTT-JJJJMMTT)”</p>
</li><li>
<p>-32  (LUT2_COMPRESS_ERROR)        “Fehler beim Komprimieren eines
LUT-Blocks”</p>
</li><li>
<p>-31  (LUT2_FILE_CORRUPTED)        “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-30  (LUT2_NO_SLOT_FREE)          “Im Inhaltsverzeichnis der LUT-Datei ist
kein Slot mehr frei”</p>
</li><li>
<p>-15  (INVALID_BLZ_FILE)           “Fehler in der blz.txt Datei (falsche
Zeilenlänge)”</p>
</li><li>
<p>-11  (FILE_WRITE_ERROR)           “kann Datei nicht schreiben”</p>
</li><li>
<p>-10  (FILE_READ_ERROR)            “kann Datei nicht lesen”</p>
</li><li>
<p>-9  (ERROR_MALLOC)               “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  (INVALID_LUT_FILE)           “die blz.lut Datei ist
inkosistent/ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li><li>
<p>7  (LUT1_FILE_GENERATED)        “ok; es wurde allerdings eine LUT-Datei im
alten Format (1.0/1.1) generiert”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1023</span>

static VALUE generate_lutfile_rb(int argc,VALUE* argv,VALUE self)
{
   char input_name[FILENAME_MAX+1],output_name[FILENAME_MAX+1],iban_blacklist[FILENAME_MAX+1];
   char user_info[256],gueltigkeit[20],buffer[16],error_msg[512];
   int retval,felder,filialen,set,len;
   VALUE input_name_rb,output_name_rb,user_info_rb,
         gueltigkeit_rb,felder_rb,filialen_rb,set_rb,iban_blacklist_rb;

   rb_scan_args(argc,argv,&quot;26&quot;,&amp;input_name_rb,&amp;output_name_rb,
         &amp;user_info_rb,&amp;gueltigkeit_rb,&amp;felder_rb,&amp;filialen_rb,&amp;set_rb,&amp;iban_blacklist_rb);

   if(TYPE(input_name_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(input_name_rb))&gt;FILENAME_MAX)len=FILENAME_MAX;
      strncpy(input_name,RSTRING_PTR(input_name_rb),len);
      *(input_name+len)=0;
   }
   else
      rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;Unable to convert given input filename.&quot;);

   if(TYPE(output_name_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(output_name_rb))&gt;FILENAME_MAX)len=FILENAME_MAX;
      strncpy(output_name,RSTRING_PTR(output_name_rb),len);
      *(output_name+len)=0;
   }
   else
      rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;Unable to convert given output filename.&quot;);

   if(NIL_P(user_info_rb)){
      *user_info=0;
   }
   else if(TYPE(user_info_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(user_info_rb))&gt;255)len=255;
      strncpy(user_info,RSTRING_PTR(user_info_rb),len);
      *(user_info+len)=0;
   }
   else
      rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;Unable to convert given user_info string.&quot;);

   if(NIL_P(gueltigkeit_rb)){
      *gueltigkeit=0;
   }
   else if(TYPE(gueltigkeit_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(gueltigkeit_rb))&gt;19)len=19;
      strncpy(gueltigkeit,RSTRING_PTR(gueltigkeit_rb),len);
      *(gueltigkeit+len)=0;
   }
   else
      rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;Unable to convert given gueltigkeit string.&quot;);

   if(NIL_P(felder_rb))
      felder=DEFAULT_LUT_FIELDS_NUM;
   else if(TYPE(felder_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(felder_rb))&gt;15)len=15;
      strncpy(buffer,RSTRING_PTR(felder_rb),len);
      *(buffer+len)=0;
      felder=atoi(buffer);
   }
   else
      felder=NUM2INT(felder_rb);

   if(NIL_P(filialen_rb))
      filialen=0;
   else if(TYPE(filialen_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(felder_rb))&gt;15)len=15;
      strncpy(buffer,RSTRING_PTR(filialen_rb),len);
      *(buffer+len)=0;
      filialen=atoi(buffer);
   }
   else
      filialen=NUM2INT(filialen_rb);

   if(NIL_P(set_rb))
      set=0;
   else if(TYPE(set_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(set_rb))&gt;15)len=15;
      strncpy(buffer,RSTRING_PTR(set_rb),len);
      *(buffer+len)=0;
      set=atoi(buffer);
   }
   else
      set=NUM2INT(set_rb);

   if(NIL_P(iban_blacklist_rb)){
      *iban_blacklist=0;
   }
   else if(TYPE(iban_blacklist_rb)==RUBY_T_STRING){
      if((len=RSTRING_LEN(iban_blacklist_rb))&gt;FILENAME_MAX)len=FILENAME_MAX;
      strncpy(iban_blacklist,RSTRING_PTR(iban_blacklist_rb),len);
      *(iban_blacklist+len)=0;
   }
   else
      rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;Unable to convert given iban file name to string.&quot;);

   retval=generate_lut2_p(input_name,output_name,user_info,gueltigkeit,felder,filialen,0,0,set);
   if(retval&lt;0)RUNTIME_ERROR(retval);
   if(*iban_blacklist)lut_keine_iban_berechnung(iban_blacklist,output_name,0);
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="iban2bic-class_method">
  
    + (<tt>Object</tt>) <strong>iban2bic</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aiban2bic%28+iban%29">KontoCheckRaw::iban2bic( iban)</h3>

<h5 id="label-KontoCheck%3A%3Aiban2bic%28+iban%29">KontoCheck::iban2bic( iban)</h5>

<p>Diese Funktion bestimmt zu einer (deutschen!) IBAN den zugehörigen BIC
(Bank Identifier Code). Der BIC wird für eine EU-Standard-Überweisung im
SEPA-Verfahren (Single Euro Payments Area) benötigt; für die deutschen
Banken ist er in der BLZ-Datei enthalten. Nähere Infos gibt es z.B. unter
<a href="http://www.bic-code.de">www.bic-code.de</a>/</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::iban2bic( iban)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>iban: die IBAN, zu der der entsprechende BIC bestimmt werden soll.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Der Rückgabewert ist ein Array mit vier Elementen: im ersten steht der BIC,
im zweiten ein Statuscode, im dritten die BLZ und im vierten die
Kontonummer (die beiden letzteren werden aus der IBAN extrahiert). Im
Fehlerfall wird für BIC, BLZ und Kontonummer nil zurückgegeben.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-68  (IBAN2BIC_ONLY_GERMAN)       “Die Funktion iban2bic() arbeitet nur mit
deutschen Bankleitzahlen”</p>
</li><li>
<p>-46  (LUT2_BIC_NOT_INITIALIZED)   “Das Feld BIC wurde nicht initialisiert”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)       “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)         “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)                “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1640</span>

static VALUE iban2bic_rb(int argc,VALUE* argv,VALUE self)
{
   char iban[128],blz[10],kto[16];
//   char error_msg[512];
   const char *bic;
   int retval;

   get_params(argc,argv,iban,NULL,NULL,NULL,3);
   bic=iban2bic(iban,&amp;retval,blz,kto);
//   if(retval&lt;0 &amp;&amp; retval!=INVALID_BLZ)RUNTIME_ERROR(retval);
   return rb_ary_new3(4,!*bic?Qnil:rb_str_new2(bic),INT2FIX(retval),
         !*blz?Qnil:rb_str_new2(blz),!*kto?Qnil:rb_str_new2(kto));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="iban_check-class_method">
  
    + (<tt>Object</tt>) <strong>iban_check</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aiban_check%28+iban%29">KontoCheckRaw::iban_check( iban)</h3>

<h5 id="label-KontoCheck%3A%3Aiban_check%28+iban%29">KontoCheck::iban_check( iban)</h5>

<p>Diese Funktion testet eine IBAN; bei deutschen Bankverbindungen wird
zusätzlich noch die Plausibilität der Bankverbindung getestet und im
Statuswert zurückgegeben. Die Rückgabe ist ein Array mit zwei Elementen: im
ersten (retval) wird das Testergebnis für die IBAN zurückgegeben, im
zweiten (bei deutschen Bankverbindungen) das Testergebnis des Kontotests.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::iban_check( iban)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>iban: die IBAN, die getestet werden soll</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Array mit zwei Elementen:</p>
<ul><li>
<p>das erste Element enthält den Statuscode für den IBAN-Test</p>
</li><li>
<p>das zweite Element enthält den Statuscode für den Test der Bankverbindung
(nur für deutsche Kontoverbindungen)</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+R%C3%BCckgabewerte+f%C3%BCr+den+IBAN-Test%3A">Mögliche Rückgabewerte für den IBAN-Test:</h4>
<ul><li>
<p>-67  (IBAN_OK_KTO_NOT)         “Die Prüfziffer der IBAN stimmt, die der
Kontonummer nicht”</p>
</li><li>
<p>-66  (KTO_OK_IBAN_NOT)         “Die Prüfziffer der Kontonummer stimmt, die
der IBAN nicht”</p>
</li><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+R%C3%BCckgabewerte+f%C3%BCr+den+Kontotest%3A">Mögliche Rückgabewerte für den Kontotest:</h4>
<ul><li>
<p>-77  (BAV_FALSE)               “BAV denkt, das Konto ist falsch
(konto_check hält es für richtig)”</p>
</li><li>
<p>-74  (NO_GERMAN_BIC)           “Ein Konto kann kann nur für deutsche Banken
geprüft werden”</p>
</li><li>
<p>-69  (MISSING_PARAMETER)       “Bei der Kontoprüfung fehlt ein notwendiger
Parameter (BLZ oder Konto)”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)    “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-29  (UNDEFINED_SUBMETHOD)     “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-12  (INVALID_KTO_LENGTH)      “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)      “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)             “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-3  (INVALID_KTO)             “das Konto ist ungültig”</p>
</li><li>
<p>-2  (NOT_IMPLEMENTED)         “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  (NOT_DEFINED)             “die Methode ist nicht definiert”</p>
</li><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li><li>
<p>2  (OK_NO_CHK)               “ok, ohne Prüfung”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1859
1860
1861
1862
1863
1864
1865
1866
1867</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1859</span>

static VALUE iban_check_rb(int argc,VALUE* argv,VALUE self)
{
   char iban[128];
   int retval,retval_kc;

   get_params(argc,argv,iban,NULL,NULL,NULL,3);
   retval=iban_check(iban,&amp;retval_kc);
   return rb_ary_new3(2,INT2FIX(retval),INT2FIX(retval_kc));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="iban_gen-class_method">
  
    + (<tt>Object</tt>) <strong>iban_gen</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aiban_gen%28+blz%2Ckto%29">KontoCheckRaw::iban_gen( blz,kto)</h3>

<h5 id="label-KontoCheck%3A%3Aiban_gen%28+kto%2Cblz%29">KontoCheck::iban_gen( kto,blz)</h5>

<p>Diese Funktion generiert aus (deutscher) BLZ und Konto einen IBAN, sowie
den zugehörigen BIC.</p>

<p>Nachdem im Mai 2013 die IBAN-Regeln zur Berechnung von IBAN und BIC aus
Kontonummer und BLZ veröffentlicht wurden, gibt es endlich ein
verbindliches Verfahren zur Bestimmung der IBAN. Die definierten
IBAN-Regeln wurden in der C-Datei eingearbeitet und werden automatisch
ausgewertet, falls der Block mit den IBAN-Regeln in der LUT-Datei enthalten
ist. Andere LUT-Dateien sollten für die IBAN-Berechnung möglichst nicht
verwendet werden, da die Anzahl der BLZs mit Sonderregelungen doch sehr
groß ist.</p>

<p>Es ist möglich, sowohl die Prüfung auf Stimmigkeit der Kontonummer als auch
die “schwarze Liste” (ausgeschlossene BLZs) zu deaktivieren. Falls die IBAN
ohne Test der Blacklist berechnet werden soll, ist vor die BLZ ein @ zu
setzen; falls auch bei falscher Bankverbindung ein IBAN berechnet werden
soll, ist vor die BLZ ein + zu setzen. Um beide Prüfungen zu deaktiviern,
kann @+ (oder +@) vor die BLZ gesetzt werden. Die so erhaltenen IBANs sind
dann u.U. allerdings wohl nicht gültig.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::iban_gen( blz,kto)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>blz: die BLZ, zu der die IBAN generiert werden soll</p>
</li><li>
<p>kto: Kontonummer</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Array mit sieben Elementen:</p>
<ul><li>
<p>das erste Element enthält die generierten IBAN in komprimierter Form</p>
</li><li>
<p>das zweite Element enthält die generierte IBAN in Papierform (mit
eingestreuten Blanks)</p>
</li><li>
<p>das dritte Element enthält den Statuscode der Funktion</p>
</li><li>
<p>das vierte Element enthält den BIC (dieser unterscheidet sich u.U. von
demjenigen der BLZ-Datei!!). Dieses und die folgenden Elemente waren
ursprünglich nicht in der Funktion enthalten und wurde erst nach Einführung
der IBAN-Regeln (Juni 2013) hinzugefügt.</p>
</li><li>
<p>das fünfte Element enthält die verwendete BLZ</p>
</li><li>
<p>das sechste Element enthält die verwendete Kontonummer</p>
</li><li>
<p>das siebte Element enthält die verwendete IBAN-Regel</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-128  (IBAN_INVALID_RULE)       “Die BLZ passt nicht zur angegebenen
IBAN-Regel”</p>
</li><li>
<p>-127  (IBAN_AMBIGUOUS_KTO)      “Die Kontonummer ist nicht eindeutig (es
gibt mehrere Möglichkeiten)”</p>
</li><li>
<p>-125  (IBAN_RULE_UNKNOWN)       “Die IBAN-Regel ist nicht bekannt”</p>
</li><li>
<p>-124  (NO_IBAN_CALCULATION)     “Für die Bankverbindung ist keine
IBAN-Berechnung erlaubt”</p>
</li><li>
<p>-123  (OLD_BLZ_OK_NEW_NOT)      “Die Bankverbindung ist mit der alten BLZ
stimmig, mit der Nachfolge-BLZ nicht”</p>
</li><li>
<p>-122  (LUT2_IBAN_REGEL_NOT_INITIALIZED) “Das Feld IBAN-Regel wurde nicht
initialisiert”</p>
</li><li>
<p>-120  (LUT2_NO_ACCOUNT_GIVEN)   “Keine Bankverbindung/IBAN angegeben”</p>
</li><li>
<p>-113  (NO_OWN_IBAN_CALCULATION) “das Institut erlaubt keine eigene
IBAN-Berechnung”</p>
</li><li>
<p>-77  (BAV_FALSE)               “BAV denkt, das Konto ist falsch
(konto_check hält es für richtig)”</p>
</li><li>
<p>-74  (NO_GERMAN_BIC)           “Ein Konto kann kann nur für deutsche Banken
geprüft werden”</p>
</li><li>
<p>-69  (MISSING_PARAMETER)       “Bei der Kontoprüfung fehlt ein notwendiger
Parameter (BLZ oder Konto)”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)    “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-29  (UNDEFINED_SUBMETHOD)     “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-12  (INVALID_KTO_LENGTH)      “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-5  (INVALID_BLZ_LENGTH)      “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  (INVALID_BLZ)             “Die Bankleitzahl ist nicht definiert”</p>
</li><li>
<p>-3  (INVALID_KTO)             “das Konto ist ungültig”</p>
</li><li>
<p>-2  (NOT_IMPLEMENTED)         “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  (NOT_DEFINED)             “die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li><li>
<p>2  (OK_NO_CHK)               “ok, ohne Prüfung”</p>
</li><li>
<p>11  (OK_UNTERKONTO_POSSIBLE)  “wahrscheinlich ok; die Kontonummer kann
allerdings (nicht angegebene) Unterkonten enthalten”</p>
</li><li>
<p>12  (OK_UNTERKONTO_GIVEN)     “wahrscheinlich ok; die Kontonummer enthält
eine Unterkontonummer”</p>
</li><li>
<p>18  (OK_KTO_REPLACED)         “ok; die Kontonummer wurde allerdings
ersetzt”</p>
</li><li>
<p>19  (OK_BLZ_REPLACED)         “ok; die Bankleitzahl wurde allerdings
ersetzt”</p>
</li><li>
<p>20  (OK_BLZ_KTO_REPLACED)     “ok; die Bankleitzahl und Kontonummer wurde
allerdings ersetzt”</p>
</li><li>
<p>21  (OK_IBAN_WITHOUT_KC_TEST) “ok; die Bankverbindung ist (ohne Test) als
richtig anzusehen”</p>
</li><li>
<p>22  (OK_INVALID_FOR_IBAN)     “ok; für IBAN ist (durch eine Regel)
allerdings ein anderer BIC definiert”</p>
</li><li>
<p>24  (OK_KTO_REPLACED_NO_PZ)   “ok; die Kontonummer wurde ersetzt, die neue
Kontonummer hat keine Prüfziffer”</p>
</li><li>
<p>25  (OK_UNTERKONTO_ATTACHED)  “ok; es wurde ein (weggelassenes) Unterkonto
angefügt”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1727</span>

static VALUE iban_gen_rb(int argc,VALUE* argv,VALUE self)
{
   char iban[128],*papier,*ptr,*dptr,blz[20],kto[20],blz2[20],kto2[20];
   const char *bic;
   int retval,regel;
   VALUE iban_rb,papier_rb,bic_rb,blz2_rb,kto2_rb;

   get_params(argc,argv,blz,kto,NULL,NULL,2);
   papier=iban_bic_gen(blz,kto,&amp;bic,blz2,kto2,&amp;retval);
   regel=-1;
   if(retval&gt;0){
      for(ptr=papier,dptr=iban;*ptr;ptr++)if(*ptr!=' ')*dptr++=*ptr;
      *dptr=0;
      iban_rb=rb_str_new2(iban);
      papier_rb=rb_str_new2(papier);
      bic_rb=rb_str_new2(bic);
      blz2_rb=rb_str_new2(blz2);
      kto2_rb=rb_str_new2(kto2);
      kc_free(papier);  /* die C-Funktion allokiert Speicher, der muß wieder freigegeben werden */
      regel=lut_iban_regel(blz,0,NULL)/100;
   }
   else
      iban_rb=papier_rb=blz2_rb=kto2_rb=bic_rb=Qnil;
   return rb_ary_new3(7,iban_rb,papier_rb,INT2FIX(retval),bic_rb,blz2_rb,kto2_rb,INT2FIX(regel));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="init-class_method">
  
    + (<tt>Object</tt>) <strong>init</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Ainit%28+%5Bp1+%5B%2Cp2+%5B%2Cset%5D%5D%5D%29">KontoCheckRaw::init( [p1 [,p2 [,set]]])</h3>

<h5 id="label-KontoCheck%3A%3Ainit%28+%5Bp1+%5B%2Cp2+%5B%2Cset%5D%5D%5D%29">KontoCheck::init( [p1 [,p2 [,set]]])</h5>

<p>Diese Funktion initialisiert die Bibliothek und lädt die gewünschten
Datenblocks in den Speicher. Alle Argumente sind optional; in konto_check.h
werden die Defaultwerte definiert.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>
<ul><li>
<p>ret=KontoCheckRaw::init( [p1 [,p2 [,set]]])</p>
</li></ul>

<h5 id="label-Beispielsaufrufe%3A">Beispielsaufrufe:</h5>
<ul><li>
<p>ret=KontoCheckRaw::init</p>
</li><li>
<p>ret=KontoCheckRaw::init( 5)</p>
</li><li>
<p>ret=KontoCheckRaw::init( “/etc/blz.lut”)</p>
</li><li>
<p>ret=KontoCheckRaw::init( 3,“/etc/blz.lut”)</p>
</li><li>
<p>ret=KontoCheckRaw::init( “/etc/blz.lut”,9,2)</p>
</li></ul>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>Die Variablen p1 und p2 stehen für den Initialisierungslevel und den
Dateinamen der LUT-Datei (in beliebiger Reihenfolge); die Zuordnung der
beiden Parameter erfolgt on the fly durch eine Typüberprüfung. Der
Dateiname ist immer als String anzugeben, der Initialisierungslevel immer
als Zahl, ansonsten gibt es eine TypeError Exception. Auf diese Weise ist
es eindeutig möglich festzustellen, wie die Parameter p1 und p2 den
Variablen lutfile und level zuzuordnen sind.</p>
</li><li>
<p>Der Initialisierungslevel ist eine Zahl zwischen 0 und 9, die die zu
ladenden Blocks angibt. Die folgenden Werte sind definiert:</p>

<pre class="code"><code>0. BLZ,PZ
1. BLZ,PZ,NAME_KURZ
2. BLZ,PZ,NAME_KURZ,BIC
3. BLZ,PZ,NAME,PLZ,ORT
4. BLZ,PZ,NAME,PLZ,ORT,BIC
5. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC
6. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ
7. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,AENDERUNG
8. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,AENDERUNG,
   LOESCHUNG
9. BLZ,PZ,NAME_NAME_KURZ,PLZ,ORT,BIC,NACHFOLGE_BLZ,AENDERUNG,
   LOESCHUNG,PAN,NR</code></pre>
</li><li>
<p>Der Parameter set bezeichnet den zu ladenden Datensatz (1 oder 2) der
LUT-Datei. Falls der Parameter set nicht angegeben oder 0 ist, wird
versucht, das aktuell gültige Set aus dem Systemdatum und dem
Gültigkeitszeitraum der in der LUT-Datei gespeicherten Sets zu bestimmen.</p>
</li></ul>

<p>Für die LUT-Datei ist als Defaultwert sowohl für den Pfad als auch den
Dateinamen eine Liste möglich, die sequenziell abgearbeitet wird; diese
wird in konto_check.h spezifiziert (Compilerzeit-Konstante der
C-Bibliothek). Die folgenden Werte sind in der aktuellen konto_check.h
definiert:</p>
<ul><li>
<p>DEFAULT_LUT_NAME blz.lut; blz.lut2f; blz.lut2</p>
</li><li>
<p>DEFAULT_LUT_PATH ., /usr/local/etc/; /etc/; /usr/local/bin/;
/opt/konto_check/ <em>(für nicht-Windows-Systeme)</em></p>
</li><li>
<p>DEFAULT_LUT_PATH .; C:; C:\Programme\konto_check  <em>(für
Windows-Systeme)</em></p>
</li></ul>

<p>Der Defaultwert für level ist ebenfalls in konto_check.h definiert; in der
aktuellen Version ist er 5. Bei diesem Level werden die Blocks BLZ,
Prüfziffer, Name, Kurzname, PLZ, Ort und BIC geladen.</p>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Es wird ein skalarer Statuscode zurückgegeben, der Auskunft über die
Initialisierung bzw. aufgetretene Fehler gibt.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-112  (KTO_CHECK_UNSUPPORTED_COMPRESSION) “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-64  (INIT_FATAL_ERROR)        “Initialisierung fehlgeschlagen (init_wait
geblockt)”</p>
</li><li>
<p>-63  (INCREMENTAL_INIT_NEEDS_INFO) “Ein inkrementelles Initialisieren
benötigt einen Info-Block in der LUT-Datei”</p>
</li><li>
<p>-62  (INCREMENTAL_INIT_FROM_DIFFERENT_FILE)   “Ein inkrementelles
Initialisieren mit einer anderen LUT-Datei ist nicht möglich”</p>
</li><li>
<p>-38  (LUT2_PARTIAL_OK)         “es wurden nicht alle Blocks geladen”</p>
</li><li>
<p>-36  (LUT2_Z_MEM_ERROR)        “Memory error in den ZLIB-Routinen”</p>
</li><li>
<p>-35  (LUT2_Z_DATA_ERROR)       “Datenfehler im komprimierten LUT-Block”</p>
</li><li>
<p>-34  (LUT2_BLOCK_NOT_IN_FILE)  “Der Block ist nicht in der LUT-Datei
enthalten”</p>
</li><li>
<p>-33  (LUT2_DECOMPRESS_ERROR)   “Fehler beim Dekomprimieren eines
LUT-Blocks”</p>
</li><li>
<p>-31  (LUT2_FILE_CORRUPTED)     “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-20  (LUT_CRC_ERROR)           “Prüfsummenfehler in der blz.lut Datei”</p>
</li><li>
<p>-10  (FILE_READ_ERROR)         “kann Datei nicht lesen”</p>
</li><li>
<p>-9  (ERROR_MALLOC)            “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  (INVALID_LUT_FILE)        “die blz.lut Datei ist inkosistent/ungültig”</p>
</li><li>
<p>-6  (NO_LUT_FILE)             “die blz.lut Datei wurde nicht gefunden”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li><li>
<p>6  (LUT1_SET_LOADED)         “Die Datei ist im alten LUT-Format (1.0/1.1)”</p>
</li></ul>

<h4 id="label-Anmerkung%3A">Anmerkung:</h4>

<p>Falls der Statuscode LUT2_PARTIAL_OK ist, waren bei der Initialisierung
nicht alle Blocks in der LUT-Datei enthalten; in vielen Situationen ist
dies mehr eine Warnung, nicht ein Fehler.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 907</span>

static VALUE init(int argc,VALUE* argv,VALUE self)
{
   char lut_name[FILENAME_MAX+1],error_msg[512];
   int retval,level,set;

   get_params_file(argc,argv,lut_name,&amp;level,&amp;set,1);
   retval=lut_init(lut_name,level,set);
   switch(retval){
      case OK:
      case LUT1_SET_LOADED:
      case LUT2_PARTIAL_OK:
         break;
      default:
         RUNTIME_ERROR(retval);
   }
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ipi_check-class_method">
  
    + (<tt>Object</tt>) <strong>ipi_check</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aipi_check%28+zweck%29">KontoCheckRaw::ipi_check( zweck)</h3>

<h5 id="label-KontoCheck%3A%3Aipi_check%28+zweck%29">KontoCheck::ipi_check( zweck)</h5>

<p>Die Funktion testet, ob ein Strukturierter Verwendungszweck gültig ist
(Anzahl Zeichen, Prüfziffer).</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::ipi_check( zweck)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>zweck: der Strukturierte Verwendungszweck, der getestet werden soll</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Zurückgegeben wird ein skalarer Statuscode.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-73  (IPI_CHECK_INVALID_LENGTH)   “Der zu validierende strukturierete
Verwendungszweck muß genau 20 Zeichen enthalten”</p>
</li><li>
<p>0  (FALSE)                      “falsch”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1938
1939
1940
1941
1942
1943
1944</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1938</span>

static VALUE ipi_check_rb(int argc,VALUE* argv,VALUE self)
{
   char zweck[128];

   get_params(argc,argv,zweck,NULL,NULL,NULL,3);
   return INT2FIX(ipi_check(zweck));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="ipi_gen-class_method">
  
    + (<tt>Object</tt>) <strong>ipi_gen</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aipi_gen%28+zweck%29">KontoCheckRaw::ipi_gen( zweck)</h3>

<h5 id="label-KontoCheck%3A%3Aipi_gen%28+zweck%29">KontoCheck::ipi_gen( zweck)</h5>

<p>Diese Funktion generiert einen “Strukturierten Verwendungszweck” für
SEPA-Überweisungen. Der Rückgabewert ist der Strukturierte Verwendungszweck
als String oder nil, falls ein Fehler aufgetreten ist.</p>

<p><em>ACHTUNG</em> Die Reihenfolge der Parameter dieser Funktion hat sich in
Version 0.2.2 geändert; der Statuscode wird nun als letzter Arraywert
zurückgegeben, die Papierform als zweiter Wert (wie bei iban_gen(). Es ist
nicht schön,so allerdings insgesamt konsistenter (ich habe auch eine
Abneigung gegen Änderungen des Interfaces, aber an dieser Stelle schien es
geboten zu sein).</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::ipi_gen( zweck)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>zweck: String für den ein Strukturierter Verwendungszweck generiert werden
soll. Der String für den Strukturierten Verwendungszweck darf maximal 18
Byte lang sein und nur alphanumerische Zeichen enthalten (also auch keine
Umlaute).</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Der Rückgabewert ist ein Array mit drei Elementen:</p>
<ul><li>
<p>im ersten steht der Strukturierte Verwendungszweck,</p>
</li><li>
<p>im zweiten die Papierform (mit eingestreuten Blanks).</p>
</li><li>
<p>im dritten ein Statuscode</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-71  (IPI_INVALID_LENGTH)         “Die Länge des IPI-Verwendungszwecks darf
maximal 18 Byte sein”</p>
</li><li>
<p>-72  (IPI_INVALID_CHARACTER)      “Im strukturierten Verwendungszweck
dürfen nur alphanumerische Zeichen vorkommen”</p>
</li><li>
<p>1  (OK)                         “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913
1914</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1903</span>

static VALUE ipi_gen_rb(int argc,VALUE* argv,VALUE self)
{
   char zweck[24],dst[24],papier[30];
   int retval;

   get_params(argc,argv,zweck,NULL,NULL,NULL,4);
   retval=ipi_gen(zweck,dst,papier);
   if(retval==OK)
      return rb_ary_new3(3,rb_str_new2(dst),rb_str_new2(papier),INT2FIX(retval));
   else
      return rb_ary_new3(3,Qnil,Qnil,INT2FIX(retval));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="keep_raw_data-class_method">
  
    + (<tt>Object</tt>) <strong>keep_raw_data</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Akeep_raw_data%28+mode%29">KontoCheckRaw::keep_raw_data( mode)</h3>

<h5 id="label-KontoCheckRaw%3A%3Aencoding%28+mode%29">KontoCheckRaw::encoding( mode)</h5>

<h5 id="label-KontoCheck%3A%3Aencoding%28+mode%29">KontoCheck::encoding( mode)</h5>

<p>Diese Funktion setzt bzw. liest das Flag keep_raw_data in der C-Bibliothek.
Falls es gesetzt ist, werden werden die Rohdaten der Blocks Name, Kurzname
und Ort im Speicher gehalten; bei einem Wechsel der Kodierung werden diese
Blocks dann auch auf die neue Kodierung umgesetzt. Für die Speicherung der
Blocks werden allerdings etwa 900 KB Hauptspeicher benötigt, die
andernfalls wieder freigegeben würden.</p>

<p>Da diese Funktion etwas exotisch ist, ist sie nur in der KontoCheckRaw
Bibliothek enthalten, nicht in KontoCheck.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval=KontoCheck::encoding( mode)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>

<p>Das Verhalten der Funktion wird durch den Parameter mode gesteuert:</p>
<ul><li>
<p>-1: Flag keep_raw_data ausschalten</p>
</li><li>
<p>1: Flag keep_raw_data einschalten</p>
</li><li>
<p>0/nil: Flag lesen</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+R%C3%BCckgabewerte">Mögliche Rückgabewerte</h4>

<p>Der Rückgabewert ist true oder false.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1305</span>

static VALUE keep_raw_data_rb(VALUE self, VALUE mode_rb)
{
   int t,mode;

   if(NIL_P(mode_rb))
      mode=0;
   else if((t=TYPE(mode_rb))==RUBY_T_STRING)
      mode=*(RSTRING_PTR(mode_rb))-'0';
   else if(t==RUBY_T_FLOAT || t==RUBY_T_FIXNUM || t==RUBY_T_BIGNUM)
      mode=FIX2INT(mode_rb);
   else  /* nicht unterstützter Typ */
      mode=0;
   return keep_raw_data(mode)?Qtrue:Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="konto_check-class_method">
  
    + (<tt>Object</tt>) <strong>konto_check</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Akonto_check%28+blz%2C+kto%29">KontoCheckRaw::konto_check( blz, kto)</h3>

<h5 id="label-KontoCheck%3A%3Akonto_check%28+blz%2C+kto%29">KontoCheck::konto_check( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::konto_check( blz, kto)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>blz: Die Bankleitzahl der zu testenden Bankverbindung</p>
</li><li>
<p>kto: Die Kontonummer der zu testenden Bankverbindung</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein skalarer Statuswert, der das Ergebnis der Prüfung enthält.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-77  BAV_FALSE               “BAV denkt, das Konto ist falsch (konto_check
hält es für richtig)”</p>
</li><li>
<p>-69  MISSING_PARAMETER       “Bei der Kontoprüfung fehlt ein notwendiger
Parameter (BLZ oder Konto)”</p>
</li><li>
<p>-40  LUT2_NOT_INITIALIZED    “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-29  UNDEFINED_SUBMETHOD     “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-12  INVALID_KTO_LENGTH      “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-5  INVALID_BLZ_LENGTH      “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  INVALID_BLZ             “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>-3  INVALID_KTO             “das Konto ist ungültig”</p>
</li><li>
<p>-2  NOT_IMPLEMENTED         “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  NOT_DEFINED             “die Methode ist nicht definiert”</p>
</li><li>
<p>0  FALSE                   “falsch”</p>
</li><li>
<p>1  OK                      “ok”</p>
</li><li>
<p>2  OK_NO_CHK               “ok, ohne Prüfung”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


561
562
563
564
565
566
567
568
569
570
571
572</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 561</span>

static VALUE konto_check(int argc,VALUE* argv,VALUE self)
{
   char kto[16],blz[16],error_msg[512];
   int retval;

   get_params(argc,argv,blz,kto,NULL,NULL,2);
   if((*blz=='0' || strlen(blz)!=8) &amp;&amp; lut_blz(kto+2,0)==OK)   /* BLZ/Kto vertauscht, altes Interface */
      rb_raise(rb_eRuntimeError,&quot;%s&quot;,&quot;It seems that you use the old interface of konto_check?\n&quot;
            &quot;Please check the order of function arguments for konto_test(); should be (blz,kto)&quot;);
   if((retval=kto_check_blz(blz,kto))==LUT2_NOT_INITIALIZED || retval==MISSING_PARAMETER)RUNTIME_ERROR(retval);
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="konto_check_pz-class_method">
  
    + (<tt>Object</tt>) <strong>konto_check_pz</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_pz%28+pz%2C+kto+%5B%2Cblz%5D%29">KontoCheckRaw::konto_check_pz( pz, kto [,blz])</h3>

<h5 id="label-KontoCheck%3A%3Akonto_check_pz%28+pz%2C+kto+%5B%2Cblz%5D%29">KontoCheck::konto_check_pz( pz, kto [,blz])</h5>

<p>Diese Funktion testet, ob eine gegebene Prüfziffer/Kontonummer-Kombination
gültig ist.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::konto_check_pz( pz, kto [,blz])</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>pz: Prüfzifferverfahren das benutzt werden soll</p>
</li><li>
<p>kto: Kontonummer die getestet werden soll</p>
</li><li>
<p>blz: Dieser Parameter ist nur für die Verfahren 52, 53, B6 und C0
notwendig; bei allen anderen Prüfzifferverfahren wird er ignoriert. Bei
diesen Verfahren geht die BLZ in die Berechnung der Prüfziffer ein. Wird
der Parameter bei einem dieser Verfahren nicht angegeben, wird stattdessen
eine Test-BLZ (wie in der Beschreibung der Prüfziffermethoden von der
Deutschen Bundesbank angegeben) eingesetzt.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Die Funktion gibt einen skalaren Statuscode zurück, der das Ergebnis der
Prüfung enthält.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-77  (BAV_FALSE)               “BAV denkt, das Konto ist falsch
(konto_check hält es für richtig)”</p>
</li><li>
<p>-69  (MISSING_PARAMETER)       “bei der Kontoprüfung fehlt ein notwendiger
Parameter (BLZ oder Konto)”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)    “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-29  (UNDEFINED_SUBMETHOD)     “die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-12  (INVALID_KTO_LENGTH)      “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-3  (INVALID_KTO)             “das Konto ist ungültig”</p>
</li><li>
<p>-2  (NOT_IMPLEMENTED)         “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  (NOT_DEFINED)             “die Methode ist nicht definiert”</p>
</li><li>
<p>0  (FALSE)                   “falsch”</p>
</li><li>
<p>1  (OK)                      “ok”</p>
</li><li>
<p>2  (OK_NO_CHK)               “ok, ohne Prüfung”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


521
522
523
524
525
526
527
528
529</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 521</span>

static VALUE konto_check_pz(int argc,VALUE* argv,VALUE self)
{
   char pz[16],blz[16],kto[16],error_msg[512];
   int retval;

   get_params(argc,argv,pz,kto,blz,NULL,5);
   if((retval=kto_check_pz(pz,kto,blz))==LUT2_NOT_INITIALIZED || retval==MISSING_PARAMETER)RUNTIME_ERROR(retval);
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="konto_check_regel-class_method">
  
    + (<tt>Object</tt>) <strong>konto_check_regel</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel( blz, kto)</h3>

<h5 id="label-KontoCheckRaw%3A%3Akonto_check_regel_dbg%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel_dbg( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheck::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%3F%28+blz%2C+kto%29">KontoCheck::konto_check_regel?( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält. Vor
der Prüfung werden die IBAN-Regeln angewendet; dabei wird u.U. BLZ und/oder
Kontonummer ersetzt.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::konto_check_regel( blz, kto)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>blz: Die Bankleitzahl der zu testenden Bankverbindung</p>
</li><li>
<p>kto: Die Kontonummer der zu testenden Bankverbindung</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein skalarer Statuswert, der das Ergebnis der Prüfung enthält.
Es sind auch die Rückgabewerte der Initialisierung möglich (wegen
iban_init()), deshalb gibt es so viele mögliche Rückgabewerte.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-135  FALSE_UNTERKONTO_ATTACHED “falsch, es wurde ein Unterkonto
hinzugefügt (IBAN-Regel)”</p>
</li><li>
<p>-133  BLZ_MARKED_AS_DELETED     “Die BLZ ist in der Bundesbank-Datei als
gelöscht markiert und somit ungültig”</p>
</li><li>
<p>-128  IBAN_INVALID_RULE         “Die BLZ passt nicht zur angegebenen
IBAN-Regel”</p>
</li><li>
<p>-127  IBAN_AMBIGUOUS_KTO        “Die Kontonummer ist nicht eindeutig (es
gibt mehrere Möglichkeiten)”</p>
</li><li>
<p>-125  IBAN_RULE_UNKNOWN         “Die IBAN-Regel ist nicht bekannt”</p>
</li><li>
<p>-124  NO_IBAN_CALCULATION       “Für die Bankverbindung ist keine
IBAN-Berechnung erlaubt”</p>
</li><li>
<p>-112  KTO_CHECK_UNSUPPORTED_COMPRESSION “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-77  BAV_FALSE                 “BAV denkt, das Konto ist falsch
(konto_check hält es für richtig)”</p>
</li><li>
<p>-69  MISSING_PARAMETER         “Für die aufgerufene Funktion fehlt ein
notwendiger Parameter”</p>
</li><li>
<p>-64  INIT_FATAL_ERROR          “Initialisierung fehlgeschlagen (init_wait
geblockt)”</p>
</li><li>
<p>-63  INCREMENTAL_INIT_NEEDS_INFO “Ein inkrementelles Initialisieren
benötigt einen Info-Block in der LUT-Datei”</p>
</li><li>
<p>-62  INCREMENTAL_INIT_FROM_DIFFERENT_FILE “Ein inkrementelles
Initialisieren mit einer anderen LUT-Datei ist nicht möglich”</p>
</li><li>
<p>-40  LUT2_NOT_INITIALIZED      “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-38  LUT2_PARTIAL_OK           “es wurden nicht alle Blocks geladen”</p>
</li><li>
<p>-36  LUT2_Z_MEM_ERROR          “Memory error in den ZLIB-Routinen”</p>
</li><li>
<p>-35  LUT2_Z_DATA_ERROR         “Datenfehler im komprimierten LUT-Block”</p>
</li><li>
<p>-34  LUT2_BLOCK_NOT_IN_FILE    “Der Block ist nicht in der LUT-Datei
enthalten”</p>
</li><li>
<p>-33  LUT2_DECOMPRESS_ERROR     “Fehler beim Dekomprimieren eines
LUT-Blocks”</p>
</li><li>
<p>-31  LUT2_FILE_CORRUPTED       “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-29  UNDEFINED_SUBMETHOD       “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-20  LUT_CRC_ERROR             “Prüfsummenfehler in der blz.lut Datei”</p>
</li><li>
<p>-12  INVALID_KTO_LENGTH        “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-10  FILE_READ_ERROR           “kann Datei nicht lesen”</p>
</li><li>
<p>-9  ERROR_MALLOC              “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  INVALID_LUT_FILE          “die blz.lut Datei ist inkosistent/ungültig”</p>
</li><li>
<p>-6  NO_LUT_FILE               “die blz.lut Datei wurde nicht gefunden”</p>
</li><li>
<p>-5  INVALID_BLZ_LENGTH        “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  INVALID_BLZ               “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>-3  INVALID_KTO               “das Konto ist ungültig”</p>
</li><li>
<p>-2  NOT_IMPLEMENTED           “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  NOT_DEFINED               “die Methode ist nicht definiert”</p>
</li><li>
<p>0  FALSE                     “falsch”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li><li>
<p>2  OK_NO_CHK                 “ok, ohne Prüfung”</p>
</li><li>
<p>6  LUT1_SET_LOADED           “Die Datei ist im alten LUT-Format (1.0/1.1)”</p>
</li><li>
<p>18  OK_KTO_REPLACED           “ok, die Kontonummer wurde allerdings
ersetzt”</p>
</li><li>
<p>21  OK_IBAN_WITHOUT_KC_TEST   “ok, die Bankverbindung ist (ohne Test) als
richtig anzusehen”</p>
</li><li>
<p>25  OK_UNTERKONTO_ATTACHED    “ok, es wurde ein (weggelassenes) Unterkonto
angefügt”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


636
637
638
639
640
641
642
643
644</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 636</span>

static VALUE konto_check_regel(int argc,VALUE* argv,VALUE self)
{
   char kto[16],blz[16],error_msg[512];
   int retval;

   get_params(argc,argv,blz,kto,NULL,NULL,2);
   if((retval=kto_check_regel(blz,kto))==LUT2_NOT_INITIALIZED || retval==MISSING_PARAMETER)RUNTIME_ERROR(retval);
   return INT2FIX(retval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="konto_check_regel_dbg-class_method">
  
    + (<tt>Object</tt>) <strong>konto_check_regel_dbg</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Akonto_check_regel_dbg%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel_dbg( blz, kto)</h3>

<h5 id="label-KontoCheckRaw%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheckRaw::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%28+blz%2C+kto%29">KontoCheck::konto_check_regel( blz, kto)</h5>

<h5 id="label-KontoCheck%3A%3Akonto_check_regel%3F%28+blz%2C+kto%29">KontoCheck::konto_check_regel?( blz, kto)</h5>

<p>Test, ob eine BLZ/Konto-Kombination eine gültige Prüfziffer enthält. Vor
der Prüfung werden die IBAN-Regeln angewendet; dabei wird u.U. BLZ und/oder
Kontonummer ersetzt. Die Funktion gibt viele Interna</p>
<dl class="rdoc-list note-list"><dt>zurück und ist daher nur in der KontoCheckRaw
<dd>
<p>Bibliothek enthalten.</p>
</dd></dl>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::konto_check_regel_dbg( blz, kto)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>blz: Die Bankleitzahl der zu testenden Bankverbindung</p>
</li><li>
<p>kto: Die Kontonummer der zu testenden Bankverbindung</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Array mit 10 Elementen, der das Ergebnis der Prüfung sowie
eine Reihe interner Werte enthält. Für den Statuscode sind auch die
Rückgabewerte der Initialisierung möglich (wegen iban_init()), deshalb gibt
es so viele mögliche Werte.</p>
<ul><li>
<p>das erste Element enthält den Statuscode</p>
</li><li>
<p>das zweite Element enthält die benutzte BLZ (die BLZ wird durch die
IBAN-Regeln u.U. ersetzt)</p>
</li><li>
<p>das dritte Element enthält die benutzte Kontonummer (wird manchmal auch
ersetzt)</p>
</li><li>
<p>das vierte Element enthält den BIC der Bank</p>
</li><li>
<p>das fünfte Element enthält die benutzte IBAN-Regel</p>
</li><li>
<p>das sechste Element enthält die Regel-Version</p>
</li><li>
<p>das siebte Element enthält Prüfziffermethode als Text</p>
</li><li>
<p>das achte Element enthält die Prüfziffermethode (numerisch)</p>
</li><li>
<p>das neunte Element enthält die Prüfziffer</p>
</li><li>
<p>das zehnte Element enthält die Position der Prüfziffer</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-135  FALSE_UNTERKONTO_ATTACHED “falsch, es wurde ein Unterkonto
hinzugefügt (IBAN-Regel)”</p>
</li><li>
<p>-133  BLZ_MARKED_AS_DELETED     “Die BLZ ist in der Bundesbank-Datei als
gelöscht markiert und somit ungültig”</p>
</li><li>
<p>-128  IBAN_INVALID_RULE         “Die BLZ passt nicht zur angegebenen
IBAN-Regel”</p>
</li><li>
<p>-127  IBAN_AMBIGUOUS_KTO        “Die Kontonummer ist nicht eindeutig (es
gibt mehrere Möglichkeiten)”</p>
</li><li>
<p>-125  IBAN_RULE_UNKNOWN         “Die IBAN-Regel ist nicht bekannt”</p>
</li><li>
<p>-124  NO_IBAN_CALCULATION       “Für die Bankverbindung ist keine
IBAN-Berechnung erlaubt”</p>
</li><li>
<p>-112  KTO_CHECK_UNSUPPORTED_COMPRESSION “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-77  BAV_FALSE                 “BAV denkt, das Konto ist falsch
(konto_check hält es für richtig)”</p>
</li><li>
<p>-69  MISSING_PARAMETER         “Für die aufgerufene Funktion fehlt ein
notwendiger Parameter”</p>
</li><li>
<p>-64  INIT_FATAL_ERROR          “Initialisierung fehlgeschlagen (init_wait
geblockt)”</p>
</li><li>
<p>-63  INCREMENTAL_INIT_NEEDS_INFO “Ein inkrementelles Initialisieren
benötigt einen Info-Block in der LUT-Datei”</p>
</li><li>
<p>-62  INCREMENTAL_INIT_FROM_DIFFERENT_FILE “Ein inkrementelles
Initialisieren mit einer anderen LUT-Datei ist nicht möglich”</p>
</li><li>
<p>-40  LUT2_NOT_INITIALIZED      “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-38  LUT2_PARTIAL_OK           “es wurden nicht alle Blocks geladen”</p>
</li><li>
<p>-36  LUT2_Z_MEM_ERROR          “Memory error in den ZLIB-Routinen”</p>
</li><li>
<p>-35  LUT2_Z_DATA_ERROR         “Datenfehler im komprimierten LUT-Block”</p>
</li><li>
<p>-34  LUT2_BLOCK_NOT_IN_FILE    “Der Block ist nicht in der LUT-Datei
enthalten”</p>
</li><li>
<p>-33  LUT2_DECOMPRESS_ERROR     “Fehler beim Dekomprimieren eines
LUT-Blocks”</p>
</li><li>
<p>-31  LUT2_FILE_CORRUPTED       “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-29  UNDEFINED_SUBMETHOD       “Die (Unter)Methode ist nicht definiert”</p>
</li><li>
<p>-20  LUT_CRC_ERROR             “Prüfsummenfehler in der blz.lut Datei”</p>
</li><li>
<p>-12  INVALID_KTO_LENGTH        “ein Konto muß zwischen 1 und 10 Stellen
haben”</p>
</li><li>
<p>-10  FILE_READ_ERROR           “kann Datei nicht lesen”</p>
</li><li>
<p>-9  ERROR_MALLOC              “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  INVALID_LUT_FILE          “die blz.lut Datei ist inkosistent/ungültig”</p>
</li><li>
<p>-6  NO_LUT_FILE               “die blz.lut Datei wurde nicht gefunden”</p>
</li><li>
<p>-5  INVALID_BLZ_LENGTH        “die Bankleitzahl ist nicht achtstellig”</p>
</li><li>
<p>-4  INVALID_BLZ               “die Bankleitzahl ist ungültig”</p>
</li><li>
<p>-3  INVALID_KTO               “das Konto ist ungültig”</p>
</li><li>
<p>-2  NOT_IMPLEMENTED           “die Methode wurde noch nicht implementiert”</p>
</li><li>
<p>-1  NOT_DEFINED               “die Methode ist nicht definiert”</p>
</li><li>
<p>0  FALSE                     “falsch”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li><li>
<p>2  OK_NO_CHK                 “ok, ohne Prüfung”</p>
</li><li>
<p>6  LUT1_SET_LOADED           “Die Datei ist im alten LUT-Format (1.0/1.1)”</p>
</li><li>
<p>18  OK_KTO_REPLACED           “ok, die Kontonummer wurde allerdings
ersetzt”</p>
</li><li>
<p>21  OK_IBAN_WITHOUT_KC_TEST   “ok, die Bankverbindung ist (ohne Test) als
richtig anzusehen”</p>
</li><li>
<p>25  OK_UNTERKONTO_ATTACHED    “ok, es wurde ein (weggelassenes) Unterkonto
angefügt”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


719
720
721
722
723
724
725
726
727
728
729
730</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 719</span>

static VALUE konto_check_regel_dbg(int argc,VALUE* argv,VALUE self)
{
   char kto[16],blz[16],kto2[16],blz2[16],error_msg[512];
   const char *bic2;
   int retval,regel;
   RETVAL rv;

   get_params(argc,argv,blz,kto,NULL,NULL,2);
   if((retval=kto_check_regel_dbg(blz,kto,blz2,kto2,&amp;bic2,&amp;regel,&amp;rv))==LUT2_NOT_INITIALIZED || retval==MISSING_PARAMETER)RUNTIME_ERROR(retval);
   return rb_ary_new3(10,INT2FIX(retval),rb_str_new2(blz2),rb_str_new2(kto2),rb_str_new2(bic2),INT2FIX(regel/100),INT2FIX(regel%100),
         rv.methode?rb_str_new2(rv.methode):Qnil,INT2FIX(rv.pz_methode),INT2FIX(rv.pz),INT2FIX(rv.pz_pos));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="load_bank_data-class_method">
  
    + (<tt>Object</tt>) <strong>load_bank_data</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aload_bank_data%28+datafile%29">KontoCheckRaw::load_bank_data( datafile)</h3>

<h5 id="label-KontoCheck%3A%3Aload_bank_data%28+datafile%29">KontoCheck::load_bank_data( datafile)</h5>

<p>Diese Funktion war die alte Initialisierungsroutine für konto_check; es ist
nun durch die Funktionen KontoCheck::init() und
KontoCheck::generate_lutfile() ersetzt. Zur Initialisierung  benutzte sie
die Textdatei der Deutschen Bundesbank und generierte daraus eine
LUT-Datei, die dann von der Initialisierungsroutine der C-Bibliothek
benutzt wurde.</p>

<p>Die init() Funktion ist wesentlich schneller (7…20 mal so schnell ohne
Generierung der Indexblocks; mit Indexblocks macht es noch wesentlich mehr
aus) und hat eine Reihe weiterer Vorteile. So ist es z.B. möglich, zwei
Datensätze mit unterschiedlichem Gültigkeitszeitraum in einer Datei zu
halten und den jeweils gültigen Satz automatisch (nach der Systemzeit)
auswählen zu lassen. Die einzelnen Datenblocks (Bankleitzahlen,
Prüfziffermethoden, PLZ, Ort…) sind in der LUT-Datei in jeweils
unabhängigen Blocks gespeichert und können einzeln geladen werden; die
Bankdatei von der Deutschen Bundesbank enthält alle Felder in einem
linearen Format, so daß einzelne Blocks nicht unabhängig von anderen
geladen werden können.</p>

<p>Die Funktion load_bank_data() wird nur noch als ein Schibbolet benutzt, um
zu testen, ob jemand das alte Interface benutzt. Bei der Routine
KontoCheck::konto_check() wurde die Reihenfolge der Parameter getauscht, so
daß man in dem Falle den alten Code umstellen muß.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval=KontoCheckRaw::load_bank_data( datafile)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>der alte Parameter datafile ist die BLZ-Datei der Deutschen Bundesbank; er
wird ignoriert.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>es erfolgt keine Rückgabe, sondern es wird nur eine runtime Exception
generiert, daß scheinbar das alte Interface benutzt wurde, dieses aber
nicht mehr unterstützt wird.</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1603
1604
1605
1606
1607
1608</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1603</span>

static VALUE load_bank_data(VALUE self, VALUE path_rb)
{
   rb_raise(rb_eRuntimeError,&quot;%s&quot;,&quot;Perhaps you used the old interface of konto_check.\n&quot;
         &quot;Use KontoCheck::init() to initialize the library\n&quot;
         &quot;and check the order of function arguments for konto_test(blz,kto)&quot;);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lut_blocks-class_method">
  
    + (<tt>Object</tt>) <strong>lut_blocks</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Alut_blocks%28+mode%29">KontoCheckRaw::lut_blocks( mode)</h3>

<h5 id="label-KontoCheck%3A%3Alut_blocks%28+mode%29">KontoCheck::lut_blocks( mode)</h5>

<p>Die Funktion gibt Auskunft, ob bei der Initialisierung alle angeforderten
Blocks der LUT-Datei geladen wurden und gibt den Dateinamen der LUT-Datei,
eine Liste der geladenen Blocks sowie eine Liste der Blocks die nicht
geladen werden konnten, zurück.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::lut_blocks( mode)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>mode: Ausgabeformat (1..3)</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Array mit vier Elementen, das den Statuscode sowie drei
Strings mit dem Dateinamen sowie den Blocklisten enthält:</p>
<ul><li>
<p>das erste Element enthält den Statuscode</p>
</li><li>
<p>das zweite Element enthält den Dateinamen der verwendeten LUT-Datei</p>
</li><li>
<p>das dritte Element enthält eine Liste der geladenen LUT-Blocks</p>
</li><li>
<p>das vierte Element enthält eine Liste der LUT-Blocks, die nicht geladen
werden konnten</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-136  LUT2_BLOCKS_MISSING       “ok, bei der Initialisierung konnten
allerdings ein oder mehrere Blocks nicht geladen werden”</p>
</li><li>
<p>-40  LUT2_NOT_INITIALIZED      “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  ERROR_MALLOC              “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 761</span>

static VALUE lut_blocks_rb(int argc,VALUE* argv,VALUE self)
{
   char *lut_filename,*lut_blocks_ok,*lut_blocks_fehler;
   int mode,retval;
   VALUE mode_rb,filename_rb,blocks_ok_rb,blocks_fehler_rb;

   rb_scan_args(argc,argv,&quot;01&quot;,&amp;mode_rb);
   if(NIL_P(mode_rb))
      mode=1;
   else{
      switch(TYPE(mode_rb)){
         case RUBY_T_FLOAT:
         case RUBY_T_FIXNUM:
         case RUBY_T_BIGNUM:
            mode=NUM2INT(mode_rb);
            break;
         default:
            mode=1;
            rb_raise(rb_eTypeError,&quot;%s&quot;,&quot;lut_blocks() requires an int parameter&quot;);
            break;
      }
   }

   if((retval=lut_blocks(mode,&amp;lut_filename,&amp;lut_blocks_ok,&amp;lut_blocks_fehler))==LUT2_NOT_INITIALIZED || retval==ERROR_MALLOC)
      filename_rb=blocks_ok_rb=blocks_fehler_rb=Qnil;
   else{
      filename_rb=rb_str_new2(lut_filename);
      blocks_ok_rb=rb_str_new2(lut_blocks_ok);
      blocks_fehler_rb=rb_str_new2(lut_blocks_fehler);
      kc_free(lut_filename);
      kc_free(lut_blocks_ok);
      kc_free(lut_blocks_fehler);
   }
   return rb_ary_new3(4,INT2FIX(retval),filename_rb,blocks_ok_rb,blocks_fehler_rb);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lut_blocks1-class_method">
  
    + (<tt>Object</tt>) <strong>lut_blocks1</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Alut_blocks1%28+%29">KontoCheckRaw::lut_blocks1( )</h3>

<h5 id="label-KontoCheckRaw%3A%3Alut_blocks%28+mode%29">KontoCheckRaw::lut_blocks( mode)</h5>

<h5 id="label-KontoCheck%3A%3Alut_blocks%28+%29">KontoCheck::lut_blocks( )</h5>

<p>Diese Funktion entspricht weitgehend der Funktion lut_blocks(); sie gibt
allerdings nur den Statuscode zurück, keine Strings. Sie wird für die
Funktion KontoCheck::lut_blocks() benutzt.</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>keine</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Rückgabe ist ein Integerwert, der Aufschluß über den aktuellen Stand der
Initialisierung gibt.</p>

<h4 id="label-M%C3%B6gliche+Statuscodes%3A">Mögliche Statuscodes:</h4>
<ul><li>
<p>-136  LUT2_BLOCKS_MISSING       “ok, bei der Initialisierung konnten
allerdings ein oder mehrere Blocks nicht geladen werden”</p>
</li><li>
<p>-40  LUT2_NOT_INITIALIZED      “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-9  ERROR_MALLOC              “kann keinen Speicher allokieren”</p>
</li><li>
<p>1  OK                        “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


817
818
819
820
821</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 817</span>

static VALUE lut_blocks1_rb(int argc,VALUE* argv,VALUE self)
{
   rb_scan_args(argc,argv,&quot;0&quot;);
   return INT2FIX(lut_blocks(0,NULL,NULL,NULL));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="lut_info-class_method">
  
    + (<tt>Object</tt>) <strong>lut_info</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Alut_info%28+%5Blutfile%5D%29">KontoCheckRaw::lut_info( [lutfile])</h3>

<h5 id="label-KontoCheck%3A%3Alut_info%28%29">KontoCheck::lut_info()</h5>

<h5 id="label-KontoCheck%3A%3Alut_info1%28+lutfile%29">KontoCheck::lut_info1( lutfile)</h5>

<h5 id="label-KontoCheck%3A%3Alut_info2%28+lutfile%29">KontoCheck::lut_info2( lutfile)</h5>

<p>Diese Funktion liefert Informationen über die Datensätze sowie die beiden
Infoblocks einer LUT-Date oder die in den Speicher geladenen Blocks.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>ret=KontoCheckRaw::lut_info( [lutfile])</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>lutfile: Name der LUT-Datei, falls angegeben. Falls der Parameter
weggelassen wird, werden Infnos über die geladenen Blocks zurückgegeben.</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>Der Rückgabewert ist ein Array mit 5 Elementen:</p>
<ul><li>
<p>das erste Element (retval) enthält den Statuscode für die Funktion
insgesamt</p>
</li><li>
<p>das zweite Element (valid1) enthält den Gültigkeitscode für den ersten
Block</p>
</li><li>
<p>das dritte Element (valid2) enthält den Gültigkeitscode für den zweiten
Block</p>
</li><li>
<p>das vierte Element (info1) enthält den erster Infoblock, oder nil, falls
der Block nicht existiert</p>
</li><li>
<p>das fünfte Element (info2) enthält den zweiter Infoblock, oder nil, falls
der Block nicht existiert</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Statuscodes+f%C3%BCr+valid1+and+valid2%3A">Mögliche Statuscodes für valid1 and valid2:</h4>
<ul><li>
<p>-105  (LUT2_NO_LONGER_VALID_BETTER)   “Beide Datensätze sind nicht mehr
gültig; dieser ist  aber jünger als der andere”</p>
</li><li>
<p>-59  (LUT2_NOT_YET_VALID)            “Der Datenblock ist noch nicht gültig”</p>
</li><li>
<p>-58  (LUT2_NO_LONGER_VALID)          “Der Datenblock ist nicht mehr gültig”</p>
</li><li>
<p>-34  (LUT2_BLOCK_NOT_IN_FILE)        “Die LUT-Datei enthält den Infoblock
nicht”</p>
</li><li>
<p>4  (LUT2_VALID)                    “Der Datenblock ist aktuell gültig”</p>
</li><li>
<p>5  (LUT2_NO_VALID_DATE)            “Der Datenblock enthält kein
Gültigkeitsdatum”</p>
</li></ul>

<h4 id="label-M%C3%B6gliche+Werte+f%C3%BCr+den+Statuscode+retval%3A">Mögliche Werte für den Statuscode retval:</h4>
<ul><li>
<p>-112  (KTO_CHECK_UNSUPPORTED_COMPRESSION) “die notwendige
Kompressions-Bibliothek wurden beim Kompilieren nicht eingebunden”</p>
</li><li>
<p>-10  (FILE_READ_ERROR)        “kann Datei nicht lesen”</p>
</li><li>
<p>-70  (LUT1_FILE_USED)         “Es wurde eine LUT-Datei im Format 1.0/1.1
geladen”</p>
</li><li>
<p>-40  (LUT2_NOT_INITIALIZED)   “die Programmbibliothek wurde noch nicht
initialisiert”</p>
</li><li>
<p>-37  (LUT2_Z_BUF_ERROR)       “Buffer error in den ZLIB Routinen”</p>
</li><li>
<p>-36  (LUT2_Z_MEM_ERROR)       “Memory error in den ZLIB-Routinen”</p>
</li><li>
<p>-35  (LUT2_Z_DATA_ERROR)      “Datenfehler im komprimierten LUT-Block”</p>
</li><li>
<p>-34  (LUT2_BLOCK_NOT_IN_FILE) “Der Block ist nicht in der LUT-Datei
enthalten”</p>
</li><li>
<p>-31  (LUT2_FILE_CORRUPTED)    “Die LUT-Datei ist korrumpiert”</p>
</li><li>
<p>-20  (LUT_CRC_ERROR)          “Prüfsummenfehler in der blz.lut Datei”</p>
</li><li>
<p>-9  (ERROR_MALLOC)           “kann keinen Speicher allokieren”</p>
</li><li>
<p>-7  (INVALID_LUT_FILE)       “die blz.lut Datei ist inkosistent/ungültig”</p>
</li><li>
<p>1  (OK)                     “ok”</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1543</span>

static VALUE lut_info_rb(int argc,VALUE* argv,VALUE self)
{
   char lut_name[FILENAME_MAX+1],*info1,*info2,error_msg[512];
   int retval,valid1,valid2;
   VALUE info1_rb,info2_rb;

   get_params_file(argc,argv,lut_name,NULL,NULL,3);
   retval=lut_info(lut_name,&amp;info1,&amp;info2,&amp;valid1,&amp;valid2);
   if(!info1)
      info1_rb=Qnil;
   else
      info1_rb=rb_str_new2(info1);
   if(!info2)
      info2_rb=Qnil;
   else
      info2_rb=rb_str_new2(info2);
   kc_free(info1);  /* die C-Funktion allokiert Speicher, der muß wieder freigegeben werden */
   kc_free(info2);
   if(retval&lt;0)RUNTIME_ERROR(retval);
   return rb_ary_new3(5,INT2FIX(retval),INT2FIX(valid1),INT2FIX(valid2),info1_rb,info2_rb);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2dos-class_method">
  
    + (<tt>Object</tt>) <strong>retval2dos</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2dos%28+retval%29">KontoCheckRaw::retval2dos( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2dos%28+retval%29">KontoCheck::retval2dos( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen String.
Der benutzte Zeichensatz ist cp850 (DOS).</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2dos( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1401
1402
1403
1404</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1401</span>

static VALUE retval2dos_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2dos(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2html-class_method">
  
    + (<tt>Object</tt>) <strong>retval2html</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2html%28+retval%29">KontoCheckRaw::retval2html( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2html%28+retval%29">KontoCheck::retval2html( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen String.
Für Umlaute werden HTML-Entities benutzt.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2html( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1422
1423
1424
1425</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1422</span>

static VALUE retval2html_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2html(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2iso-class_method">
  
    + (<tt>Object</tt>) <strong>retval2iso</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2iso%28+retval%29">KontoCheckRaw::retval2iso( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2iso%28+retval%29">KontoCheck::retval2iso( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen String.
Der benutzte Zeichensatz ist ISO 8859-1.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2iso( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1359
1360
1361
1362</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1359</span>

static VALUE retval2iso_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2iso(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2txt-class_method">
  
    + (<tt>Object</tt>) <strong>retval2txt</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2txt%28+retval%29">KontoCheckRaw::retval2txt( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2txt%28+retval%29">KontoCheck::retval2txt( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen String.
Der benutzte Zeichensatz wird über die Funktion KontoCheckRaw::encoding()
festgelegt. Falls diese Funktion nicht aufgerufen wurde, wird der Wert des
Makros DEFAULT_ENCODING aus konto_check.h benutzt.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2txt( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1338
1339
1340
1341</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1338</span>

static VALUE retval2txt_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2txt(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2txt_short-class_method">
  
    + (<tt>Object</tt>) <strong>retval2txt_short</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2txt_short%28+retval%29">KontoCheckRaw::retval2txt_short( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2txt_short%28+retval%29">KontoCheck::retval2txt_short( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen kurzen
String. Die Ausgabe ist der Makroname, wie er in C benutzt wird.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2txt_short( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1380
1381
1382
1383</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1380</span>

static VALUE retval2txt_short_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2txt_short(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="retval2utf8-class_method">
  
    + (<tt>Object</tt>) <strong>retval2utf8</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aretval2utf8%28+retval%29">KontoCheckRaw::retval2utf8( retval)</h3>

<h5 id="label-KontoCheck%3A%3Aretval2utf8%28+retval%29">KontoCheck::retval2utf8( retval)</h5>

<p>Diese Funktion konvertiert einen numerischen Rückgabewert in einen String.
Der benutzte Zeichensatz ist UTF-8.</p>

<h4 id="label-Aufruf%3A">Aufruf:</h4>

<p>retval_str=KontoCheckRaw::retval2utf8( retval)</p>

<h4 id="label-Parameter%3A">Parameter:</h4>
<ul><li>
<p>retval: der zu konvertierende numerische Rückgabewert</p>
</li></ul>

<h4 id="label-R%C3%BCckgabe%3A">Rückgabe:</h4>

<p>String, der dem Rückgabewert entspricht</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1443
1444
1445
1446</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 1443</span>

static VALUE retval2utf8_rb(VALUE self, VALUE retval)
{
  return rb_str_new2(kto_check_retval2utf8(FIX2INT(retval)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="version-class_method">
  
    + (<tt>Object</tt>) <strong>version</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<h3 id="label-KontoCheckRaw%3A%3Aversion%28+%5Bmode%5D+%29">KontoCheckRaw::version( [mode] )</h3>

<h5 id="label-KontoCheck%3A%3Aversion%28+%5Bmode%5D+%29">KontoCheck::version( [mode] )</h5>

<p>Diese Funktion gibt die Versions-Infos der C-Bibliothek zurück.</p>

<h4 id="label-M%C3%B6gliche+Werte+f%C3%BCr+mode%3A">Mögliche Werte für mode:</h4>
<ul><li>
<p>0 bzw. ohne Parameter: Versionsstring der C-Bibliothek</p>
</li><li>
<p>1: Versionsnummer</p>
</li><li>
<p>2: Versionsdatum</p>
</li><li>
<p>3: Compilerdatum und -zeit</p>
</li><li>
<p>4: Datum der Prüfziffermethoden</p>
</li><li>
<p>5: Datum der IBAN-Regeln</p>
</li><li>
<p>6: Klartext-Datum der Bibliotheksversion</p>
</li><li>
<p>7: Versionstyp (devel, beta, final)</p>
</li></ul>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/konto_check_raw/konto_check_raw_ruby.c', line 2972</span>

static VALUE version_rb(int argc,VALUE* argv,VALUE self)
{
   int level;
   VALUE level_rb;

   rb_scan_args(argc,argv,&quot;01&quot;,&amp;level_rb);
   if(NIL_P(level_rb))
      level=0;
   else
      level=NUM2INT(level_rb);
   return rb_str_new2(get_kto_check_version_x(level));
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Sat Jan  4 00:18:18 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.2.1 (ruby-1.9.3).
</div>

  </body>
</html>